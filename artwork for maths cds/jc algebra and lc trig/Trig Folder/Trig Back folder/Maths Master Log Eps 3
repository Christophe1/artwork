%!PS-Adobe-3.0 EPSF-3.0%%Creator: Adobe Illustrator(r) 6.0.1%%For: (Lorcan) (  )%%Title: (Maths Master Log Eps 3)%%CreationDate: (27/11/01) (12:46 pm)%%BoundingBox: 137 550 415 662%%HiResBoundingBox: 137.9155 550.2774 414.7085 661.0559%%DocumentProcessColors: Cyan Magenta Yellow Black%%DocumentSuppliedResources: procset Adobe_level2_AI5 1.0 0%%+ procset Adobe_screens_AI5 1.0 0%%+ procset Adobe_blend_AI5 1.0 0%%+ procset Adobe_Illustrator_AI6_vars Adobe_Illustrator_AI6%%+ procset Adobe_Illustrator_AI5 1.0 0%AI5_FileFormat 2.1%AI3_ColorUsage: Color%%CMYKCustomColor: 1 0.5 0 0 (Blue)%%+ 0 0.7 1 0 (Orange Red)%%AI6_ColorSeparationSet: 1 1 (AI6 Default Color Separation Set)%%+ Options: 1 16 0 1 0 1 1 1 0 1 1 1 1 18 0 0 0 0 0 0 0 0 -1 -1%%+ PPD: 1 21 0 0 60 45 2 2 1 0 0 1 0 0 0 0 0 0 0 0 0 0 ()%AI3_TemplateBox: 306 396 306 396%AI3_TileBox: 30 31 582 761%AI3_DocumentPreview: Macintosh_ColorPic%AI5_ArtSize: 612 792%AI5_RulerUnits: 1%AI5_ArtFlags: 1 0 0 1 0 0 0 1 0%AI5_TargetResolution: 800%AI5_NumLayers: 1%AI5_OpenToView: -234 864 -1.5 746 649 58 1 1 2 40%AI5_OpenViewLayers: 7%%EndComments%%BeginProlog% ------------------------------------------------------%%BeginResource: procset Adobe_level2_AI5 1.2 0%%Title: (Adobe Illustrator (R) Version 5.0 Level 2 Emulation)%%Version: 1.2 0%%CreationDate: (04/10/93) ()%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)% ------------------------------------------------------userdict /Adobe_level2_AI5 23 dict dup begin	put% use packed arrays immediately	% packedarray emulation	/packedarray where not	{		userdict begin		/packedarray		{			array astore readonly		} bind def		/setpacking /pop load def		/currentpacking false def		end		0	} if	pop% activate packing now	userdict /defaultpacking currentpacking put true setpacking% initialize, terminate	% note : no binding loop needed here by design	/initialize	{		Adobe_level2_AI5 begin	} bind def	/terminate	{		currentdict Adobe_level2_AI5 eq		{			end		} if	} bind def% mark for later stack clean-up	mark% custom color business	/setcustomcolor where not	{		/findcmykcustomcolor		{			5 packedarray		} bind def		/setcustomcolor		{			exch aload pop pop			4			{				4 index mul 4 1 roll			} repeat			5 -1 roll pop			setcmykcolor		}	% don't bind 'setcmykcolor in this procedure		def	} if%	new version checks for non-numeric version strings (5.0.1 fix bh 10/25/93)%	/gt38? {version cvx exec} stopped {pop true} {38 gt} ifelse def	%	newer version handles errors on clones with cvx or exec which would leave junk on the stack%	(bh 12/2/93)	/gt38? mark {version cvr cvx exec} stopped {cleartomark true} {38 gt exch pop} ifelse def	userdict /deviceDPI 72 0 matrix defaultmatrix dtransform dup mul exch dup mul add sqrt put% test for Level 2 availability	userdict /level2?	systemdict /languagelevel known dup	{		pop systemdict /languagelevel get 2 ge	} if	put/level2ScreenFreq		%	halftoneDict level2ScreenFreq screenFreq{	begin		60	% 60 lpi is default		HalftoneType 1 eq		{			pop Frequency		} if		HalftoneType 2 eq		{			pop GrayFrequency		} if		HalftoneType 5 eq		{			pop Default level2ScreenFreq		} if	end} bind defuserdict /currentScreenFreq  	level2? {currenthalftone level2ScreenFreq} {currentscreen pop pop} ifelse putlevel2? not	{		% LEVEL 1+ EMULATIONS (typesetter/color printer extensions)		% cmyk => gray conversion emulation		% note this revision approved by Ed Taft		% for correcting the out of gamut problem		% in our current emulations		% don't bind these guys so 'setgray/currentgray can be overloaded		/setcmykcolor where not		{			% see red book II, pp. 305			/setcmykcolor			{				exch .11 mul add exch .59 mul add exch .3 mul add				1 exch sub setgray			} def		} if		/currentcmykcolor where not		{			/currentcmykcolor			{				0 0 0 1 currentgray sub			} def		} if		% LEVEL 2 EMULATIONS		% setoverprint emulation		/setoverprint where not		{			/setoverprint /pop load def		} if		% selectfont emulation		/selectfont where not		{			/selectfont			{				exch findfont exch				dup type /arraytype eq				{					makefont				}				{					scalefont				} ifelse				setfont			} bind def		} if		% cshow emulation		/cshow where not		{			% {proc} (string)			/cshow			{				[				0 0 5 -1 roll aload pop				] cvx bind forall			} bind def		} if	} if% clean up	cleartomark	/anyColor?	{		add add add 0 ne	} bind def	/testColor	{		gsave		setcmykcolor currentcmykcolor		grestore	} bind def	/testCMYKColorThrough	{		testColor anyColor?	} bind def	userdict /composite?	level2?	{		gsave 1 1 1 1 setcmykcolor currentcmykcolor grestore		add add add 4 eq	}	{		1 0 0 0 testCMYKColorThrough		0 1 0 0 testCMYKColorThrough		0 0 1 0 testCMYKColorThrough		0 0 0 1 testCMYKColorThrough		and and and	} ifelse	put% *** other separation state tests if we're not on a composite page		composite? not	{		userdict begin		gsave		/cyan? 1 0 0 0 testCMYKColorThrough def		/magenta? 0 1 0 0 testCMYKColorThrough def		/yellow? 0 0 1 0 testCMYKColorThrough def		/black? 0 0 0 1 testCMYKColorThrough def		grestore		/isCMYKSep? cyan? magenta? yellow? black? or or or def		/customColor? isCMYKSep? not def		end	} if	end defaultpacking setpacking%%EndResource% ------------------------------------------------------%%BeginResource: procset Adobe_screens_AI5 1.2 0%%Title: (Adobe Illustrator (R) Version 5.0 Custom Halftone Screens ProcSet)%%Version: 1.2 0%%CreationDate: (03/24/93) ()%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)% ------------------------------------------------------userdict /defaultpacking currentpacking put true setpackingsystemdict beginuserdict /Adobe_screens_AI5 13 dict dup beginput/initialize{	Adobe_screens_AI5 begin	/screenid		deviceDPI 600 gt composite? not or		{		-1		}		{			deviceDPI currentScreenFreq 			dup dup 60 ge exch 150 le and deviceDPI 300 le and		{			pop 60		} if		div 1.41421 div 0.5 add cvi		} ifelse	def	% (currentscreen parms are: ) print currentscreen pop == ==% (devicedpi= ) print deviceDPI ==% (screenid= ) print screenid ==% (composite?= ) print composite? ==% (vertDPI= ) print 0 72 matrix defaultmatrix dtransform dup mul exch dup mul add sqrt ==	2 screenid eq	{		/customsize 16 def		/customdata /customdata2 def		setcustomscreen	} if		3 screenid eq	{		/customsize 24 def		/customdata /customdata3 def		setcustomscreen	} if		4 screenid eq	{		/customsize 16 def		/customdata /customdata4 def		setcustomscreen	} if		5 screenid eq	{		/customsize 20 def		/customdata /customdata5 def		setcustomscreen	} if		6 screenid eq	{		/customsize 24 def		/customdata /customdata6 def		setcustomscreen	} if		7 screenid eq	{		/customsize 28 def		/customdata /customdata7 def		setcustomscreen	} if		8 screenid eq	{		/customsize 16 def		/customdata /customdata8 def		setcustomscreen	} if} def/terminate{	currentdict Adobe_screens_AI5 eq	{		end	} if} def/setcustomscreen{	deviceDPI customsize div 0	{		1 add 2 div customsize mul cvi exch		1 add 2 div customsize mul cvi exch		customsize mul add		customdata load exch get 256 div	} setscreen} def/customdata2 28 28 mul string defcurrentfile customdata2 readhexstring4180E8694988E2634382EA6B4B8AE061A01939C8A81737C2A21B3BCAAA1636C0F8795998F6775796FA7B5B9AF57656952ED8B80727D6B60F2FDABA0626D5B50E4E8DE6674786EE6F4F8EE5664685ED6EAD1434C6A61F3FCEAE1232C5A51E3ECDF3745493FE7F5F9EF1725291FD7E5E9D24D3B30C2CDEBE0222D1B10A2ADDBD044483EB6C4C8BE1624281E96A4A89E364A31C3CCBAB1535C1A11A3AC9A91838C3FB7C5C9BF4755594F97A5A99F778589730DBBB0525D4B40D2DD9B90828D7B710508FE4654584EC6D4D8CE7684887EF70AF1131C4A41D3DCCAC1333C7A72040CFF0715190FC7D5D9CF2735392FF80609F21D0B00929DCBC0323D2B20B2BDFBF01000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata3 28 28 mul string defcurrentfile customdata3 readhexstring011DC7F5E73D0421CBF3E43A021EC8F6E83E0522CCF2E43A2B648BC4A0762F688AC39E732C658CC5A177306989C29D72D5B6521A6192D9B55219608FD6B6531B6193DAB451185F8FFCEE440C28D2FCED430B27D1FDEF450C29D3FBEC420A26D0BEA77D366F83BCA77C356E87BFA87E377082BBA67B346D86145B99E0AE4A125998DFB14E155C9AE1AD4A115897DEB04D0623CDF4E63C0420CAF8EA400723CDF4E53B031FC9F7E93F316988C19F752E678EC6A378326A88C09F742D668DC6A278DBB350175E91D8B8551C6395DCB24F165D90D7B7541C6294FAEC420925CFFFF1470E2BD5F9EB410824CEFEF0460D2AD4BAA57A336C85BEAA80397180B9A479336B84BDA97F387181105797DDAF4C145A9CE3AB480F5696DDAE4B13599BE2AC49021EC8F6E83E0522CCF2E43A011DC7F5E73D0421CBF3E43A2C658CC5A177306989C29D722B648BC4A0762F688AC39E73D6B6531B6193DAB451185F8FD5B6521A6192D9B55219608FFDEF450C29D3FBEC420A26D0FCEE440C28D2FCED430B27D1BFA87E377082BBA67B346D86BEA77D366F83BCA77C356E87155C9AE1AD4A115897DEB04D145B99E0AE4A125998DFB14E0723CDF4E53B031FC9F7E93F0623CDF4E63C0420CAF8EA40326A88C09F742D668DC6A278316988C19F752E678EC6A378DCB24F165D90D7B7541C6294DBB350175E91D8B8551C6395F9EB410824CEFEF0460D2AD4FAEC420925CFFFF1470E2BD5B9A479336B84BDA97F387181BAA57A336C85BEAA803971800F5696DDAE4B13599BE2AC49105797DDAF4C145A9CE3AB4800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata4 28 28 mul string defcurrentfile customdata4 readhexstring1139B8E0FAD2531B133BBAE2F8D05119417180A6AE9A7B4B437382A5AD987949C08867272F6F92CAC28A66262E6E90C8E8DE5F070F37B6F2EADD5E060E36B5F0FED6571F173FBEE6FDD5561E163EBDE5AB9E7F4F477786A1A99D7E4E467685A32C6C96CEC68E62222A6A95CDC58D64240C34B3F6EED95A020A32B1F5EDDB5C04143CBBE3F9D1521A123AB9E1FBD3541C447483A4AC997A4A427281A7AF9B7C4CC38B65252D6D91C9C1896828307093CBEBDC5D050D35B4F1E9DF60081038B7F3FCD4551D153DBCE4FFD758201840BFE7A89C7D4D457584A2AA9F8050487887A0296994CCC48C63232B6B97CFC78F61210931B0F4ECDA5B030B33B2F7EFD85901000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata5 28 28 mul string defcurrentfile customdata5 readhexstring010B34C3EBFCF7CE3F16020C35C4EDFBF6CD3E15102552A4D6EADDB5632B112654A5D5EADCB3622A3958768499C19E8C7C5E3A59778498C19D8B7B5DC8A9937047334C7587AFC9AA936F46324B7485AEF1E5BC6B1E0A2351A3D8F2E4BC6A1E092351A2D7FFF9D14219050F38C6EFFEF9D04118040E37C6EFE8E0B7662D142856A8D3E7DFB7652D132856A7D4BF9C8E7F603D5B7A8195BE9A8E7E603C5B798297314A7389B2CCAD906D442F497289B1CBAC926E4508214FA1DBF4E2B9671B07204EA0DAF4E3BA691C030D36C5EDFBF6CD3F16010C34C3ECFDF8CF4017122654A6D4E9DDB4622A112553A5D6EBDEB5642C3B59788397C09C8B7C5D3A58778599C29E8C7D5FCAAB926E46314B7486AFC8AA947048334D7587B0F2E4BB691D082250A1D8F1E6BD6B1F0A2452A3D9FDF8CF4118030E36C5EEFFFAD1421A050F38C7F0E6DFB6642C132755A7D3E8E1B8662E152957A8D2BE9A8D7E5F3B5A798296BF9B8F80613D5C7B80952F487188B1CAAC916D443049728AB3CCAE906C43061F4D9FDAF3E2BA681C07214FA0DBF5E1B8671A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata6 28 28 mul string defcurrentfile customdata6 readhexstring081A44B6E0F2FDECC150250C091B45B6E1F3FCEBC04F240C1D336199C7D8DCD3A56C37221E33619AC8D7DBD2A46B36214864798091AEB1958C7E694C49657A8190ADB0948B7D684BB99D8475593C405C7888A1BEBA9E8574583B3F5B7888A0BDE4CBAA712E1215326098CFE8E4CCA9712D1114315F97CEE7F5F1C6552B04071943B5DFFAF6F0C6542A03061842B4DEF9FFEDC352270E0B1C47B8E3F4FEECC251260D0A1C46B7E2F4DAD5A76E39232035639CCAD5D9D4A66D38231F34629BC9D6AF938E806A4E4A677C838FABAE928D7F694D4A667B828FAC3E5A778AA3BFBC9F8772563A3D597689A2BEBB9F8673573A14305E97D1EAE6CDA76F2B0F132F5D96D0E9E5CDA8702C10051742B3DDFCF8EEC4522801041641B2DDFBF7EFC5532902091B45B6E1F3FCEBC04F240C081A44B6E0F2FDECC150250C1E33619AC8D7DBD2A46B36211D336199C7D8DCD3A56C372249657A8190ADB0948B7D684B4864798091AEB1958C7E694CBA9E8574583B3F5B7888A0BDB99D8475593C405C7888A1BEE4CCA9712D1114315F97CEE7E4CBAA712E1215326098CFE8F6F0C6542A03061842B4DEF9F5F1C6552B04071943B5DFFAFEECC251260D0A1C46B7E2F4FFEDC352270E0B1C47B8E3F4D9D4A66D38231F34629BC9D6DAD5A76E39232035639CCAD5AE928D7F694D4A667B828FACAF938E806A4E4A677C838FAB3D597689A2BEBB9F8673573A3E5A778AA3BFBC9F8772563A132F5D96D0E9E5CDA8702C1014305E97D1EAE6CDA76F2B0F041641B2DDFBF7EFC5532902051742B3DDFCF8EEC452280100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata7 28 28 mul string defcurrentfile customdata7 readhexstring01061B44B7E1F5FEFBE6BD4A210C01071B45B8E1F6FDFBE6BC4A200B09132A54A7D1EAF5EED9B05D331609142B55A8D2EAF4EED9AF5C32161D2D3D6993C1CBE0CEC59B7140301E2E3D6A93C0CADFCDC49A713F3047576C7B828DA2B6A48F867E6F5A48576C7C828CA1B6A38F867E6E59BAAA958A78634E4451667A8498ADBAAB968977624E4350657A8398ADE3D4C99F7539251A273C6892C2D7E4D4C89E7539241A273B6891C1D6F8F2DDB460371005122A53A7D0ECF9F2DDB360360F05122953A6D0EBFFFDE8BE4C220D03081D46B9E3F7FFFCE7BD4B210D02071C46B8E2F7F3F0DBB15E34180B152C56A9D3E8F3EFDAB05D34170A142C55A9D2E9DFCCC69C7341321F2F3F6B94BFC9DECCC59C7241311F2E3E6A94BFCAB5A38E8780705B49596D7D808BA0B4A28D877F6F5B48586D7C818BA043506479859AAFBCAC978876614C424F64798499AEBBAB968977624D19263B6791C3D8E5D6C79D73372318253A6690C3D7E5D5C79E74382304112952A5CFEDFAF0DBB25E350E03102851A5CEECF9F1DCB25F360E01071B45B8E1F6FDFBE6BC4A200B01061B44B7E1F5FEFBE6BD4A210C09142B55A8D2EAF4EED9AF5C321609132A54A7D1EAF5EED9B05D33161E2E3D6A93C0CADFCDC49A713F301D2D3D6993C1CBE0CEC59B71403048576C7C828CA1B6A38F867E6E5947576C7B828DA2B6A48F867E6F5ABAAB968977624E4350657A8398ADBAAA958A78634E4451667A8498ADE4D4C89E7539241A273B6891C1D6E3D4C99F7539251A273C6892C2D7F9F2DDB360360F05122953A6D0EBF8F2DDB460371005122A53A7D0ECFFFCE7BD4B210D02071C46B8E2F7FFFDE8BE4C220D03081D46B9E3F7F3EFDAB05D34170A142C55A9D2E9F3F0DBB15E34180B152C56A9D3E8DECCC59C7241311F2E3E6A94BFCADFCCC69C7341321F2F3F6B94BFC9B4A28D877F6F5B48586D7C818BA0B5A38E8780705B49596D7D808BA0424F64798499AEBBAB968977624D43506479859AAFBCAC978876614C18253A6690C3D7E5D5C79E74382319263B6791C3D8E5D6C79D73372303102851A5CEECF9F1DCB25F360E04112952A5CFEDFAF0DBB25E350Epop pop/customdata8 28 28 mul string defcurrentfile customdata8 readhexstring050F2747B6D6EEF8FEF4DCBC4D2D1507111D375F9EC6E0E9EBE6CCA4653D1F132939556F8EA8C1D1D3C3AE9475573B2B4961717D808999B1B39B8B867F73634BB8A090827A6A5A42445C6C7C8492A2BAD8C8AA97785232222434546E8DACCADAF0E2CFA768401A0A0C1C365E9DC5E4F2FAF7DFBF50301802040E2646B5D5EDFCFFF5DDBD4E2E160806102848B7D7EFF9EAE7CDA5663E2014121E38609FC7E1E8D2C2AF9576583C2C2A3A56708FA9C0D0B29A8A878074644C4A62727E818898B0435B6B7B8593A3BBB9A19183796959412333536D8CADCBDBD9C9AB96775131210B1B355D9CC4E5F3F1E3CEA6673F1909030D2545B4D4ECFDFBF6DEBE4F2F1701000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop popendenddefaultpacking setpacking%%EndResource% ------------------------------------------------------%%BeginResource: procset Adobe_blend_AI5 1.4 0%%Title: (Adobe Illustrator (R) Version 5.0 Blend ProcSet)%%Version: 1.4 0%%CreationDate: (11/19/93) ()%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)% ------------------------------------------------------userdict /defaultpacking currentpacking put true setpackinguserdict /Adobe_blend_AI5 70 dict dup beginput/bd{	bind def} bind def/xs{	exch store} bd% null procedure/nullProc{	{	}} def/initialize	% varsDict mainDict initialize -{	pop pop	Adobe_blend_AI5 begin		Adobe_blend_AI5_vars begin			% define _contoneDevice if necessary			/_contoneDevice where			{				pop			}			{				/_contoneDevice false def				} ifelse								% define dpi threshold for fast case (tRectOK == true) if necessary			/_dpiThreshold where			{				pop			}			{					/_dpiThreshold 600 def			} ifelse						% define screen frequency threshold for fast case (tRectOK == true) if necessary			/_screenFreqThreshold where			{				pop			}			{					/_screenFreqThreshold 150 def			} ifelse						% define "tile w/ rects" flag			/tRectOK? deviceDPI _dpiThreshold le currentScreenFreq _screenFreqThreshold le and _contoneDevice not and def	% we need an inverted current transfer function	% to use image with color data values	% new transfer inversion procedure to call system transfer procedures	% also moved dfn to here instead of in prolog body (5.0.1 fix bh 10/25/93)	/invertXfer	{		[		{			1 exch sub				} /exec load systemdict/currenttransfer get exec /exec load				] cvx systemdict/settransfer get exec			} bd			/spotDict 3 dict dup begin				/nSpots 2 def				/spot1 7 dict def				/spot2 7 dict def			end			def			% pick up systemdict definitions for setgray, fill, and image if doing separations			composite?			{				/_setgray_ /setgray load def				/_fill_ /fill load def				/_image_ /image load def			}			{				/_setgray_ systemdict/setgray get def				/_fill_ systemdict/fill get def				/_image_ systemdict/image get def			} ifelse		} bd		/terminate		{			currentdict Adobe_blend_AI5_vars eq			{			end			currentdict Adobe_blend_AI5 eq			{			end		} if	} if} bd% define _compositeSpotDevice if necessary/_compositeSpotDevice where{	% force composite? on if _compositeSpotDevice is enabled	begin		_compositeSpotDevice 0 ne {userdict /composite? true put} if	end}{	/_compositeSpotDevice 0 def	} ifelse	/nullString () def/d255 256 array def	% 0/255, 1/255, 2/255, etc.0 1 255{	d255 exch dup 255 div put} bind for/d255- 256 array def	% 255/255, 254/255, 253/255, etc0 1 255{	d255- exch 1 d255 2 index get sub put} bind for/dUserSpace matrix defaultmatrix defcurrentdict /Adobe_blend_AI5_vars 89 dict dup beginput{	/f /F /s /S /b /B}{	null def} bind forall% utility scratch string/byte 1 string def% use this for temporary save...restoring/sSave null def/setSSave{	save /sSave exch store} bind def% stubs for on-the-fly defined procedures/Bm null def/doBlend null def/startC? false def/endC? false def/fCMYK? null def/startTint 0 def/endTint 0 def/bSMatrix matrix def/bUMatrix matrix def/dMatrix matrix def/inLine? true def/pTState? false def/bHi? false def/yHi 0 def/xHi 0 def% level 1 typesetters w/ image operator problems% 	noImg == true -> don't ever call the image operator/noImg /lv1Fix where{	pop lv1Fix}{	false} ifelsedef/ccAry1 5 array def/ccTint 0 def/spotColor? false def/colorimage? true def[/tint1Data/tint2Data/spotDict/bAxis/ubAxis/pChange/optimize?/nSamples/sInc/blendProc/_bn/xBCInc/yBCInc/bInc/bRender/cBName/cBType/nColors/color?/blend?/colorType/cData/cDataLen/bDataLen/rampPoint/midPoint/endPoint/blendLength/blackData/yeData/mgData/cyData/cnt1/ndx/_fill/tmpcounttomark{	null def} bindrepeatpopcurrentdictendcurrentdictendexchbeginbegin% define utilities and 'getRData template% all get data procs need these% utility procedures/unitSq{	0 0 moveto 0 1 lineto 1 1 lineto 1 0 lineto closepath} bd/gMark{	counttomark 2 add -1 roll} bd/setCustomColor	%	c m y k name tint setCustomColor -{	dup /ccTint exch store	1 exch sub 6 1 roll	ccAry1 astore	exch setcustomcolor} bd/currentCustomColor	% - currentCustomColor - c m y k name tint{	ccAry1 aload pop ccTint} bd% allow override of /nsetcustomcolor/nsetcustomcolor where {	pop}{	/nsetcustomcolor	% 	c m y k spotDict nsetcustomcolor -	{		pop setcmykcolor		} bd} ifelse% allow override of /nsetcustomcolorend/nsetcustomcolorend where {	pop}{	/nsetcustomcolorend	% 	- nsetcustomcolorend -	{	} bd} ifelse/setBSpace{	newpath bUMatrix astore concat unitSq} bd/setCStop{	dup 0 eq	{		pop				% hack to set a fake spot color for the black->spot, spot->black cases		spotColor?			{			dup 1 exch sub /ccTint exch def			ccAry1 4 /Black put			} if		setgray	}	{		1 eq		{			setcmykcolor		}		{			% *** check for force cmyk			composite? not colorType 2 lt and			{				forceCMYK			}			{				setCustomColor			} ifelse		} ifelse	} ifelse} bd% *** utility to convert gray value into 8 byte string/makeByte{	/tmp 0 store	255 mul cvi	8 string 8	{		dup tmp 3 index put /tmp tmp 1 add store	} repeat	exch pop} bd/setImgSpace{	cDataLen 1 8	2 index 0 0 1 0 0 dMatrix astore} bd/bwImage{	% (in bwImage) ==	setImgSpace cData /_image_ load	{		exec	} stopped	{		$error /errorname get /undefinedresult ne		{			stop		}		{			pop pop pop pop pop		} ifelse	} if} bd% define these only for level 2level2?{	/bFill	{		% 		(in level2 bFill\n) print		_fill	} def	/bCImg	{%		(in level2 bCImg\n) print		/cDataLen bDataLen store		setImgSpace		setSSave		expandSpot		cyData mgData yeData cData		expandCMYK		true 4 spotDict	% push spot dict as well		{			ncolorimage		} stopped		{			$error /errorname get /undefinedresult ne			{				stop			}			{				10				{					pop				} repeat			} ifelse		} if		sSave restore	} bd} if/expandOne	% input is a single integer or string: output is a string{			dup type /stringtype ne			{				% build a new string with constant value				cDataLen string				exch				% string value				% we don't have to fill the string if the value is 0				dup 0 ne				{					255 mul cvi					% string value					0 1 cDataLen 1 sub					{						3 copy						% string value ndx string value ndx						exch put pop					} for				} if				pop			} if} bd/expandSpot{	spotColor?	{		spotDict begin			spot1 begin				tintImage type /nulltype ne				{					tintImage expandOne /tintImage exch def				} if		 	end			spot2 begin				tintImage type /nulltype ne				{					tintImage expandOne /tintImage exch def				} if		 	end		end	} if} bd% scans arguments (cmyk) and substitutes strings of the appropriate length for integer constants/expandCMYK{%	(in expandCMYK) ==	% check all color values for constants	% c m y k ==> c m y k (all strings)	4	{		expandOne 4 1 roll	} repeat} bd% define 'colorimage emulation % only for level 1 and no 'colorimage present	/colorimage where dup{	% *** (using direct calls to colorimage\n) print	exch pop	% if it's there we can use it directly		% allow override of /ncolorimage	/ncolorimage where	{		pop	}	{		/ncolorimage {pop colorimage} bd % discard spot dict arg 	} ifelse} ifnot{	/ncolorimage where 	{		pop	}	{		% *** (defining level 1 colorimage emulation\n) print		/colorimage? false store		/ncolorimage		{			% discard true 4 spotDict arguments			pop pop pop			% *** wrapped in save...restore to reclaim vm		setSSave		% we re-define colorvariables here		% because we might be doing the 1 byte case		/blackData xs		/yeData xs		/mgData xs		/cyData xs		/cnt1 0 store		[		byte dup 0		cyData dup type /stringtype eq		{			/cnt1 cvx /get cvx d255 /exch cvx /get cvx .3 /mul cvx		}		{			.3 mul		} ifelse		mgData dup type /stringtype eq		{			/cnt1 cvx /get cvx d255 /exch cvx /get cvx .59 /mul cvx		}		{			.59 mul		} ifelse		yeData dup type /stringtype eq		{			/cnt1 cvx /get cvx d255 /exch cvx /get cvx .11 /mul cvx		}		{			.11 mul		} ifelse		blackData dup type /stringtype eq		{			/cnt1 cvx /get cvx d255 /exch cvx /get cvx		} if		/add cvx /add cvx /add cvx 1 /exch cvx /sub cvx		/dup cvx 0 /lt cvx		{			pop 0		} /if cvx		/dup cvx 1 /gt cvx		{			pop 1		} /if cvx		255 /mul cvx /cvi cvx		% *** check for out of range		256 /mod cvx		/dup cvx 0 /lt cvx		{			pop 0		} /if cvx		/put cvx		/cnt1 dup cvx 1 /add cvx /store cvx		] cvx		bind			_image_ 		sSave restore	} bd	} ifelse} if% define these only for level 1level2? not{	/bCImg	{		%		(entry level 1 bCImg\n) print		/cDataLen bDataLen store		setImgSpace		setSSave		expandSpot		cyData mgData yeData cData		colorimage? 		{			expandCMYK		} if	% (no need to expand if we have our own ncolorimage...)		true 4 spotDict		{			ncolorimage		} stopped		{			$error /errorname get /undefinedresult ne			{				stop			}			{				10				{					pop				} repeat			} ifelse		} if		sSave restore		% *** (exit level 1 bCImg\n) print		} bd	/bwFill	{		%	(in bwFill) ==		setSSave		/cDataLen 8 store		/cData currentgray makeByte store		bwImage		sSave restore	} bd	/c1ImgFill	{		%		(in c1ImgFill) ==		setSSave		/cDataLen 8 store		setImgSpace		spotColor?		{			spotDict begin				spot1 begin					currentCustomColor makeByte /tintImage exch def					/name exch def					/spot_K exch def					/spot_Y exch def					/spot_M exch def					/spot_C exch def				end				spot2 initSpotData			end		} if		currentcmykcolor		4		{			makeByte 4 1 roll		} repeat		true 4 spotDict		{			ncolorimage		} stopped		{			$error /errorname get /undefinedresult ne			{				stop			}			{				10				{					pop				} repeat			} ifelse		} if		sSave restore	} bd	/bFill	noImg	{		{			_fill		}	}	{		{			color?			{				c1ImgFill			}			{				bwFill			} ifelse		}	} ifelse	bd} if% end level 1 specific procedures% *** composite procedures% composite? not { setScratchSave } ifcomposite?{	% *** (defining composite blend data procedures\n) print	% *** we're on composite page so don't have to worry	% *** about knockout, etc.	/bCFun	{		% *** (in composite bCFun\n) print		% *** (color? = ) print color? ==		% *** (spotColor? = ) print spotColor? ==		color?		{			cyData dup type /stringtype eq			{				/ndx cvx /get cvx d255 /exch cvx /get cvx			} if			mgData dup type /stringtype eq			{				/ndx cvx /get cvx d255 /exch cvx /get cvx			} if			yeData dup type /stringtype eq			{				/ndx cvx /get cvx d255 /exch cvx /get cvx			} if			cData dup type /stringtype eq			{				/ndx cvx /get cvx d255 /exch cvx /get cvx			} if			% store tint values in the spot dicts			spotColor?			{				spotDict begin					/spotDict cvx /begin cvx					spot1 begin						tintImage dup type /stringtype eq						{							/ndx cvx /get cvx d255- /exch cvx /get cvx						}						{	% Invert the tintValue for constant custom ink data							dup type /nulltype ne 							{								name type /nametype ne {1 exch sub} if							} if						} ifelse					end					/spot1 cvx /tintValue 3 -1 /roll cvx /put cvx					spot2 begin						tintImage dup type /stringtype eq						{							/ndx cvx /get cvx d255- /exch cvx /get cvx						}						{	% Invert the tintValue for constant custom ink data							dup type /nulltype ne 							{								name type /nametype ne {1 exch sub} if							} if						} ifelse					end					/spot2 cvx /tintValue 3 -1 /roll cvx /put cvx					/end cvx % spotDict				end	% spotDict				/spotDict cvx				/nsetcustomcolor cvx			}			{				/setcmykcolor cvx			} ifelse		}		{			cData /ndx cvx /get cvx			d255 /exch cvx /get cvx			/setgray cvx		} ifelse	} bd% *** new Bc for composite plate	/Bc	{		% *** (\nin composite Bc nColors = ) print		% *** nColors ==			% *** (blend? = ) print blend? ==		newpath		gsave		setBSpace		nColors 1 eq		{			% discard midPoint and rampPoint			pop pop			% *** (setting color for blend final cap : colorType = ) print colorType ==				setCStop		} if		bFill		grestore		% *** (exit Bc\n) print						} bd	/linealBm	{		/nColors dup load 1 sub store		% *** (\nin composite linealBm :  nColors = ) print nColors ==		% *** linear blend color type selection here		% *** (blend? = ) print blend? ==		newpath		gsave		setBSpace		blend?		{			linImg		}		{			bFill		} ifelse		grestore		% changed			nColors 1 gt		{			% *** (calling getRData in /linealBm\n) print			getRData		} if		% *** (exit linealBm\n)print	} bd	/rdBm	{		/nColors dup load 1 sub store		% fill the path		_fill		% *** (in composite rdBm nColors = ) print nColors ==		gsave		% set the initial blend space		% and fill the initial circle		bUMatrix astore concat		% calculate the hilite vectors in blend space		% save re-calculation in calls to 'rdBlend/'rdPrep		bHi?		{			xHi yHi bUMatrix idtransform /yHi exch store /xHi exch store			rampPoint 1 lt			{				1 rampPoint sub dup xHi mul exch yHi mul translate			} if		} if		nColors		{			% *** (in radial blend loop blend? = ) print blend? ==			% *** (rampPoint = ) print rampPoint ==			% *** (midPoint = ) print midPoint ==% *** we can skip the blend only if there's no hilite !			% image the path with radius 'rampPoint			0 0 rampPoint 0 360 arc			_fill			blend? bHi? or			{				rdBlend			} if			nColors 1 gt			{				% *** (calling getRData from end of rdBm\n) print					getRData			} if			/nColors dup load 1 sub store		} repeat		/nColors 1 store		grestore	} bd	/cGetRData	{		setCStop		/blend?		cData type /stringtype eq		dup not color? and		{			pop			cyData type /stringtype eq			mgData type /stringtype eq			yeData type /stringtype eq			or or		} if		store	} def	/cGetRData} if% composite? not { scratchSave restore } if/eCStop{	% gray 0									3	% c m y k 1								6	% c m y k (name) tint 2			8	% c m y k (name) tint 3			8			mark	1 index 3 mul 3 add dup 8 gt	{		pop 8	} if	1 roll	cleartomark} bd% *** non-composite plate specific procedures% *** define the 'getRData procedure% *** based on color separation state% *** define the cmyk or custom paramteters% composite? { setScratchSave } ifcomposite? not{	% *** (defining non-composite blend data procedures\n) print	% we don't need explicit overprint handling if its level 2	% because we're using fill for all blend caps	/knockOut	level2?	{		{			0 0 0 0 setcmykcolor _fill		}	}	{		% enforce level1 fill overprint semantics for white in gradients (bh 3/26/94)		%	noImg case is handled by similar code for _fill		/bFill noImg		{			{				_fill			}		}		{			{				_of true eq				{					currentgray 1 ne					{						bwFill					} if				}				{					bwFill				} ifelse			}		} ifelse		def		% make whiteByte 8 bytes long (bh 3/27/94)		/whiteByte 1 makeByte def		noImg		{			{				0 0 0 0 setcmykcolor _fill			}		}		{			{				% *** (in level 1 knockout\n) print				cBType 0 eq				{					% linear					setSSave					/cData whiteByte store						% whiteByte is really 8 bytes long (bh 3/27/94)					/cDataLen 8 store					bwImage					sSave restore				}				{					% radial					_fill				} ifelse			}		} ifelse	} ifelse	bd	/bCFun	{		cData dup type /stringtype ne		{			color?			{				1 exch sub			} if		}		{			/ndx cvx /get cvx			color? customColor? not and			{				d255-			}			{				d255			} ifelse			/exch cvx /get cvx		} ifelse		/_setgray_ cvx	} bd	/eCCBlend	{		% *** (in eCCBlend\n) print		% c m y k (name) tint2 3 midPoint rampPoint c m y k (name) tint1 3		% new data possibilities with change in format 06 12		% 0 0 midPoint rampPoint c m y k (name) tint1 3		% 0 0 0 0 1 midPoint rampPoint c m y k (name) tint1 3		% c m y k (name) tint2 3 midPoint rampPoint 0 0		% c m y k (name) tint2 3 midPoint rampPoint 0 0 0 0 1% *** isCMYKSep? { (customcolor tint blend on a cmyk plate\n)} { (customcolor tint blend on a custom plate\n)} ifelse print		dup 3 eq		{			% customcolor is on top			% next color stop is either custom, 0 gray, or 0 0 0 0 cmyk			pop			mark 7 1 roll			% colorSpec colorStyle midPoint rampPoint mark c m y k (name1) tint			% we do the blend using 'tint1Data if a 100% push of the current custom			% color results in black color only on the current plate			6 copy ccThrough? dup /blend? xs			{				/startC? true store				setCustomColor				customColor?				{					/cData tint1Data store					setCDataLen				} if				/endC?				3 index 3 eq				{					4 index 1 ne				}				{					false				} ifelse				store			} if			cleartomark			% colorSpec colorStyle midPoint rampPoint			stop		} if		% starts with zero gray or 0 0 0 0 cmyk		% forget the color; we're already at white !		1 eq		{			pop pop pop		} if		pop		% skip the startC		/startC? false store		% c m y k (name) tint2 3 midPoint rampPoint		% we do the blend if the next color goes through		% and if its tint is not white		6		{			8 index		} repeat		ccThrough? dup /blend? xs		{			/endC? true store			blend? not			{				stop			} if			% if it's a customcolor blend, we use 'tint1Data			customColor?			{				/cData tint1Data store				setCDataLen			} if		} if		% c m y k (name) tint2 3 midPoint rampPoint			% *** (exit evalCustomBlend\n) print	} bd	/handleOP	{		_of not		{			knockOut		} if	} bd	% added radial handle overprint proc (bh 3/26/94)	/handleROP	{		_of not		{			0 0 0 0 setcmykcolor _fill		}		{			newpath			} ifelse	} bd	/rdBm	{		/nColors dup load 1 sub store		% handle fill or overprint (bh 3/26/94) 		%	(was composite? blend? or _of not or {_fill}{newpath} ifelse		blend? 		{			_fill		}		{			handleROP		} ifelse		gsave		bUMatrix astore concat		bHi?		{			xHi yHi bUMatrix idtransform /yHi exch store /xHi exch store			rampPoint 1 lt			{				1 rampPoint sub dup xHi mul exch yHi mul translate			} if		} if		nColors		{			0 0 rampPoint 0 360 arc			blend?			{				cData type /stringtype ne bHi? not and				{					% *** invert value if 'color?					cData color?					{						1 exch sub					} if					_setgray_ 					_fill_ 				}				{					cData type /stringtype ne					{						/cDataLen 1 store						/bDataLen 1 store	% added (bh 10/12/93)					} if					rdBlend				} ifelse			}			{				% rewrote this section (bh 3/26/94)								handleROP	% handle the overprint 								% translate the radial hilight if necessary				pTState?				{					/bAxis rampPoint endPoint sub store					xHi bAxis mul yHi bAxis mul translate				} if			} ifelse							nColors 1 gt			{				getRData			} if			/nColors dup load 1 sub store		} repeat		/nColors 1 store		grestore	} bd% define resoures needed for both custom color	% and cmyk separations	% new defn of ccThrough? (bh 3/22/94)	/ccThrough?	{		gsave		pop 0 setCustomColor		currentcmykcolor		grestore		anyColor?	} bd	/forceCMYK	{		exch pop		1 exch sub 5 1 roll		4		{			4 index mul 4 1 roll		} repeat		% ***	fake Separator out to believe its white		% ***	if there's no color on the current channel		0		cCMYKData dup /cData ne		{			dup /yeData eq			{				pop 1 add			}			{				/mgData eq				{					2				}				{					3				} ifelse				add			} ifelse			0		} if		pop		index		0 eq		{			pop pop pop pop 0 0 0 0		} if		setcmykcolor		pop		/fCMYK? true store	} bd% *** end cap for cmyk separation plates	/endCapSepBc	{		% *** (entry cmyk sep end cap\n) print		% colorSpec colorStyle midPoint rampPoint		pop pop% set the final color stop		dup 0 eq		{			pop			setgray		}		{			1 eq			{				setcmykcolor			}			{				% if the colortype is 1				% then we are looking at the end of a blend				% from gray > customColor or cmyk > customColor				% to make sure it goes through				% we have to force it				colorType 1 eq				{					forceCMYK				}				{					% if the colortype is > 1 then					% we are at the end of a customcolor tint blend					% or a customcolor > customcolor blend% for a tint custom color blend we can rely					% on the normal mechanism to either put the					% color through or skip it % for a customcolor > customcolor blend					% if either or both colors went through					% we would have used forceCMYK					% to set the first color					% and fCMYK? = true										fCMYK?					{						forceCMYK					}					{						setCustomColor					} ifelse				} ifelse			} ifelse		} ifelse		currentcmykcolor anyColor? 		blend? and	% changed 'or' to 'and'	(bh 3/27/94)		{			bFill		}		{			handleOP		} ifelse		% *** (exit cmyk sep end cap\n) print	} bd} if% composite? { scratchSave restore } if/cCMYKData 0 def% *** cmyk separation procedurescomposite? dup not{	pop customColor?} ifnot{	%	customColor? { setScratchSave } if	% *** (defining cmyk blend data procedures\n) print	% which cmyk plate are we on ?	/cCMYKData	/cyData /mgData /yeData /cData	black? not	{		yellow?		{			exch		}		{			magenta?			{				3			}			{				4			} ifelse			-1 roll		} ifelse	} if	4 1 roll pop pop pop	store	% *** (current cmyk channel = ) print cCMYKData ==	/Bc	{		% *** (\nin separation Bc nColors = ) print nColors ==			% *** (blend? = ) print blend? ==		gsave		setBSpace		nColors 1 gt		{			% start cap			% *** (entry sep start cap\n) print						blend? currentcmykcolor anyColor? and			{				bFill			}			{				handleOP			} ifelse% *** (exit sep start cap\n) print		}		{			endCapSepBc		} ifelse		grestore		newpath% *** (exit Bc\n) print	} bd	/linealBm	{		/nColors dup load 1 sub store% *** (\nin cmyk sep linealBm :  nColors = ) print nColors ==		% *** linear blend color type selection here		% *** (blend? = ) print blend? ==		newpath		gsave		setBSpace		blend?		{			cCMYKData load dup type /stringtype eq			{				dup length /cDataLen xs				/cData xs				gsave				colorType 0 ne noImg not and				{					invertXfer				} if				linImg				grestore			}			{				pop bFill			} ifelse		}		{			handleOP		} ifelse		grestore% changed			nColors 1 gt		{			% *** (calling getRData in /linealBm\n) print			getRData		} if% *** (exit linealBm\n)print	} bd	/cmykGetRData	{		% *** (in cmykGetRData\n) print		% assume no forced call to setcmykcolor		/fCMYK? false store		blend?		{			% get the data in a 'stopped so we can boogie out quickly			{				cmykDataProcs colorType get exec			} stopped			pop			% *** (return from cmyk data selection\n) print			% *** (blend? = ) print blend? ==			% *** (fCMYK? = ) print fCMYK? ==			% if we are doing the blend, put the current channel data into			% cData and take its length			blend?			{				/cData cCMYKData load store				setCDataLen			} if			% on return if blend? = true and fCMYK? = true			% for a custom > 0 or a custom > 0 0 0 0 blend    colorType = 1			% setcmyk color call has been forced from custom color definition			% for a blend from custom color to custom color colorType = 3			% the first custom color does not go through and the second one does			% and we had to setcmyk color from the first custom color definition		} if		% *** (exit cmykGetRData\n) print	} def	/cmykDataProcs	[	% gray blend on cmyk plate	{		pop		% we do the blend only if		% we're on the black plate		black? dup /blend? xs		{			setgray			0		} if		pop	}	% cmyk blend on cmyk plates	{		% at this point we have the c m y k data strings or values		% and we know there's some data in the channel		% which is either a non-zero constant or a string		cCMYKData load dup type /stringtype ne		{			% current channel data is a non-zero constant			% we can use this for a fill			% special cases of 0% gray and 0 0 0 0 cmyk			% do not arise here			% *** (cmyk blend with constant data on current cmyk channel\n) print								0 0 0			cyan? not			{				4 magenta?				{					1				}				{					yellow?					{						2					}					{						3					} ifelse				} ifelse				roll			} if			% set blend? flag to false if this plate has no ink from this blend (bh 3/18/94)			4 copy add add add 0 eq			{				/blend? false store			} if						setcmykcolor			/startC? true store			/endC? true store			eCStop			stop		} if		pop		% at this point we know the channel data is a string		dup 0 eq		{			pop			% gray > ? blend on cmyk plate			setgray			% color colorStyle midPoint rampPoint		}		{			1 eq			{				% color colorStyle midPoint rampPoint c m y k				% cmyk > ? blend on cmyk plate				setcmykcolor			}			{				% *** (custom color > ? blend on cmyk plate\n) print				% custom color > ?? blend on cmyk plate				% force it to go through whether it goes through now or not				forceCMYK			} ifelse		} ifelse	} bind% customColor? { scratchSave restore } if% isCMYKSep? { setScratchSave } if% tint customcolor blend on cmyk plate	/eCCBlend load% (customcolor or black) to (customcolor or black) blend on cmyk plate	%	at least one of the colors is a custom color	{		% (customcolor|black > customcolor|black blend on cmyk plate\n) print		% if it's a radial, swap tint data		cBType 1 eq		{			tint1Data tint2Data			/tint1Data xs			/tint2Data xs		} if		0 eq		{			% a gray color spec			%			(first color is a gray value) ==			black?			{				setgray			}			{				0 0 0 4 -1 roll 1 exch sub setcmykcolor			} ifelse			% c m y k (name2) tint 2|3 midPoint rampPoint			% we do the blend if we're on the black plate OR			% if a 100% push of the next custom			% color results in color on the current plate			% copy the next custom color to preserve stack			black?			{				/blend? true store			} if			6			{				8 index			} repeat			ccThrough?			{				/blend? true store			}			{				black?				{					/cData tint1Data store					setCDataLen				}				{					/blend? false store				} ifelse			} ifelse		}		{			mark 7 1 roll			% c m y k (name2) tint 2|3 midPoint rampPoint mark c m y k (name1) tint			% 100% push of the current custom			% color results in any black on the current plate ?			6 copy ccThrough?			{				% *** (first customcolor goes through\n) print								% at this point if blend? = true				% we can assume the first color is going through and stop				% we force the color to cmyk here				% even though it goes through				% to set the 'fCMYK? flag				% for use in the blend cap				% if the second color does not go through				forceCMYK				pop				stop			} if			% *** (first customcolor does not go through\n) print				% the first custom color doesn't go through			% we must now test the next custom color			% we have to keep the first customcolor around			% to possibly force a color set using setcmykcolor			% to get the start cap right			% get colortype of next stop			9 index 0 eq			{				%				(2nd stop is a gray value) ==				black? dup /blend? xs				{					% set the startcap color to white					pop 1 setgray					/cData tint2Data store					setCDataLen					0				} if				pop			}			{				% otherwise a custom color spec (colortype==3)%				(2nd stop is a custom color) ==				% c m y k (name2) tint 2|3 midPoint rampPoint mark c m y k (name1) tint				% we do the blend if a 100% push of the next custom				% color results in color on the current plate				% copy the next custom color to preserve stack				/blend?				6				{					16 index				} repeat				ccThrough?				store				% if blend? is true now,				% the first color doesn't go through and the second does				blend?				{					% *** (second customcolor goes through\n) print						% force setcmykcolor to the first color					forceCMYK				} if			} ifelse			% *** blend? not { (second customcolor does not go through\n) print	 } if			cleartomark		} ifelse	} bind	] def	/cmykGetRData} if% *** custom color separation procedurescomposite? dup not{	pop isCMYKSep?} ifnot{	% *** (defining custom blend data procedures\n) print	% end cap for custom plates	% on entry colorstop is custom	% c m y k (name) tint 2|3 midPoint rampPoint	/endCapSepBc	{		/white? false store		pop pop		dup 0 eq		{			pop			/white? 1 index 1 eq store			setgray		}		{			1 eq			{				setcmykcolor			}			{				setCustomColor			} ifelse		} ifelse%% new	(bh 11/22/93)		currentcmykcolor anyColor?		endC? or		blend? and		{			bFill		}		{			handleOP		} ifelse	} bd	/Bc	{		% *** (\nin custom Bc nColors = ) print nColors ==			% *** (blend? = ) print blend? ==		gsave		setBSpace		nColors 1 gt		{			% start cap			% *** (entry sep start cap\n) print			blend? startC? and			{				bFill			}			{				handleOP			} ifelse% *** (exit sep start cap\n) print			}		{			endCapSepBc		} ifelse		grestore		newpath% ***	(exit Bc\n) print	} bd	/linealBm	{		/nColors dup load 1 sub store% *** (\nin custom sep linealBm :  nColors = ) print nColors ==		% *** linear blend color type selection here		% *** (blend? = ) print blend? ==		newpath		gsave		setBSpace		blend?		{			cData type /stringtype eq			{				linImg			}			{				bFill			} ifelse		}		{			handleOP		} ifelse		grestore		nColors 1 gt		{			% *** (calling getRData in /linealBm\n) print			getRData		} if% *** (exit linealBm\n)print	} bd% used only in custom get data	/discardCMY	{		counttomark 4 add -3 roll pop pop pop	} bd	/testTopCC	{		6 copy ccThrough?	} bd	/getCRamp	{		% *** (in getCRamp\n) print			% *** (getting data for blend on customcolor plate\n) print		{			ccDataProcs colorType 2 sub get exec		} stopped pop		% we might have no data in the black channel		% but be forcing the blend, so update 'cDataLen if needed		blend? cDataLen 0 eq and		{			/cDataLen bDataLen store		} if		% *** (return from custom data selection\n) print		% *** (blend? = ) print blend? ==		% *** (fCMYK? = ) print fCMYK? ==		% on return		% if blend? = false :  no blend, knock out based on overprint		% if blend? = true		% if colorType = 1 and fCMYK? = true		% we have a blend from 0 > custom or 0 0 0 0 > custom		% or custom > 0 or custom > 0 0 0 0 		% the initial color has been set		% and we need to image the blend on this plate using the cmyk strings		% which is all the data we have anyhow		% if colorType = 2				% initial color set		% cData has tint1Data : do the blend		% if colorType = 3				% initial color set or next color set		% cData has either tint1Data or tint2Data : do the blend				} bd	/ccGetRData	{		% *** (enter ccGetRData\n) print		% assume no forced call to setcmykcolor		/fCMYK? false store		% assume we do no caps		/startC? false store		/endC? false store% new test for setting blend? flag : set it to false only if %	colorType is 0 (gray) or colorType is 1 (cmyk) (bh 3/22/94)		colorType 2 lt		{			/blend? false def		} if		blend?		{			% *** (getting custom data\n) print			getCRamp% *** (start cap ? ) print startC? ==% *** (end cap ? ) print endC? ==		}		{			% *** (skipping getting custom data because of blend type\n) print			setCStop		} ifelse		blend?		{			/blend? cData 1 ne store			blend?			{				cData dup type /stringtype ne				{					1 exch sub /cData xs 0				} if				pop			} if		} if% *** (exit ccGetRData\n) print		} def	/ccDataProcs	[% customcolor tint blend on a custom plate	/eCCBlend load% customcolor|black to customcolor|black blend on a customcolor plate	{		%		(in ccDataProc #1) ==		% if it's a radial, swap tint data		cBType 1 eq		{			tint1Data tint2Data			/tint1Data xs			/tint2Data xs		} if		0 eq		{			% a gray color spec			%			(first color is a gray value) ==			/blend? false store			pop		}		{			% *** (customcolor to customcolor blend on a customcolor plate\n) print			% c m y k (name2) tint 2 midPoint rampPoint mark c m y k (name1) tint			% we do the blend if the current or next custom color			% goes through on the current plate			% test the first color if			mark 7 1 roll			% we do the blend using tint1Data if a 100% push of the current custom			% color results in black color only on the current plate			testTopCC			{				% *** (first color goes through\n) print													% we do the start cap on this plate if the first tint is non-zero				% c m y k (name2) tint 2 midPoint rampPoint mark c m y k (name1) tint				/blend? 1 index 1 ne store				/startC? blend? store				/endC? false store				blend? not				{					cleartomark stop				} if				% leave the end cap false in this case				% *** (customcolor ramp using tint1Data\n) print																			% check tint1Data for ramp contents				/cData tint1Data store				setCDataLen				setCustomColor				pop				stop			} if			cleartomark		} ifelse%		(first color does not go through\n) print											% if the first custom color doesn't go through we		% must now consider the next one%		2 index (colortype= ) print ==		% get colortype of next stop		2 index 0 eq		{			%			(2nd stop is a gray value) ==			/blend? false store		}		{			% otherwise a custom color spec (colortype==3)			%			(2nd stop is a custom color) ==			% c m y k (name) tint 3 midPoint rampPoint			mark 6			{				9 index			} repeat			% we do the blend using tint2Data if a 100% push of the next custom			% color results in color on the current plate			testTopCC dup /blend? xs% dup { (second color goes through\n) print } { (second color does not go through\n) print } ifelse			{				% *** (customcolor ramp using tint2Data\n) print				% check tint2Data for ramp contents				% c m y k (name) tint 3 midPoint rampPoint mark c m y k (name) tint				% we do the end cap on this plate if the final tint is non-zero				/blend? 1 index 1 ne store				/endC? blend? store				/startC? false store				blend? not				{					cleartomark stop				} if				% leave the start cap false in this case				% note we do not set the customcolor here !				/cData tint2Data store				setCDataLen			} if			cleartomark		} ifelse	} bind	] def	/ccGetRData} if% define the plate specific data fetch and analyze procedure% *** (get data procedure = ) print dup ==load Adobe_blend_AI5_vars /getData 3 -1 roll put/setCDataLen{	/cDataLen 0 cData dup type /stringtype eq	{		length exch	} if	pop store} bd% isCMYKSep? { scratchSave restore } if/initSpotData	% dict initSpotData -{	begin		/name null def		/tintImage null def		/tintValue null def		/spot_C  null def		/spot_M  null def		/spot_Y  null def		/spot_K  null def	end} bd/getRData{%	(in getRData\n) print	/colorType gMark store	_compositeSpotDevice 0 ne	{		spotDict begin			spot1 initSpotData			spot2 initSpotData		end		/spotColor? colorType 2 eq colorType 3 eq or def	} 	{		/spotColor? false store	} ifelse	/blend? true store	0 0 0 0 setcmykcolor	100 div /rampPoint xs% (between 13 and 87%) 	100 div /midPoint xs	% *** get the end point now	%	we're looking at the NEXT color stop (starting w/ rampPoint)	% colorSpec colorStyle midPoint rampPoint 0 0	% colorSpec colorStyle midPoint rampPoint c m y k 1	% colorSpec colorStyle midPoint rampPoint c m y k (name) tint 3		dup 0 eq	{		2	}	{		dup 1 eq		{			5		}		{			% otherwise is 3			_compositeSpotDevice 0 ne			{				spotDict begin					spot1 begin						/name 3 index def						/spot_K 4 index def						/spot_Y 5 index def						/spot_M 6 index def						/spot_C 7 index def					end				end			} if			7		} ifelse	} ifelse	/tmp exch def	tmp index 100 div /endPoint xs	_compositeSpotDevice 0 ne	{		tmp 2 add index 3 eq		{			/tmp tmp 4 add def			tmp index dup 			spotDict begin				spot1/name get ne				{					spot2 begin						/name exch def						/spot_K tmp 2 add index def						/spot_Y tmp 3 add index def						/spot_M tmp 4 add index def						/spot_C tmp 5 add index def					end				}				{					pop				} ifelse			end		} if	} if	/color? colorType 0 gt store		colorType 3 eq	{		/tint2Data gMark store	} if		colorType 2 ge	{		/tint1Data gMark store	} if	_compositeSpotDevice 0 ne	{		spotDict begin					colorType 2 ge			{				colorType 3 eq				{					spot2 begin						/tintImage cBType 0 eq {tint2Data} {tint1Data} ifelse def						name null eq {/name /Black def} if					end				} if				spot1 begin					/tintImage cBType 0 eq colorType 2 eq or {tint1Data} {tint2Data} ifelse def					colorType 2 eq 					{						% If the spot1 name is still null, then we need to grab it						% from spot2 dict and set the spot2 dict name to null.						% (this happens when the first color stop is white)						name null eq 						{							/name spot2/name get def							spot2/name null put						} if					}					{ % else colorType is 3						name null eq {/name /Black def} if					} ifelse				end			} if		end	} if		/cData gMark store	setCDataLen	colorType 0 gt	{		counttomark 4 add -3 roll		/yeData xs		/mgData xs		/cyData xs	} if	% *** can quit here if data not well-formed	% at this point all the data is off the stack	blend?	{		/bDataLen		cDataLen dup 0 eq color? and		{			[			cyData mgData yeData			]			{				dup type /stringtype eq				{					length exch pop exit				} if				pop			} forall		} if		store		bDataLen 0 eq		{			/bDataLen 1 store		} if		getData		blend?		{			composite? cDataLen 0 eq and			{				/cDataLen bDataLen store			} if		} if	}	{		% *** erase the color stop if we're quitting early		setCStop	} ifelse} bd/Bg{	% set to initial white	0 0 0 0 setcmykcolor	6	{		pop	} repeat	/blendLength xs	pop pop pop% *** (\n\nin Bg : ) print dup ==	/cBName xs	/bRender xs	bRender 2 ne	{		% if we're not on a composite plate,		% make sure the overprint flag is updated		% for the blend as a whole		composite? not		{			% make sure the overprint flag is updated			_of setoverprint		} if		% we always clip to the path		_eo {eoclip} {clip} ifelse		_bn cBName 2 copy known		{			get			mark exch aload pop			/cBType xs			% *** (nColors = ) print dup ==			/nColors xs			mark exch aload pop			0 0		} if		pop pop		getRData		cBType 0 eq		{			% *** /doBlend is now defined in /linealBm for lineals			% *** (lineal blend\n) print			/linealBm		}		{			bHi?			{				/pTState? nColors 2 gt store			} if			/doBlend /rdBlend load store			/rdBm		} ifelse	}	{		inLine? not		{			mark mark		} if		/Bc dup		{			cleartomark mark		} bd		/nullProc	} ifelse	load /Bm xs% *** (exit Bg\n) print} bd/linImgnoImg{	{		newpath doRctBlend	}}{	{		% cData holds a string		% *** (entering linImg\n) print				/doBlend		color? composite? and		{			/bCImg		}		{			/bwImage		} ifelse% *** (blend procedure : ) print dup ==		load		store			0 0 moveto		% added composite condition for rectangle tiling (bh 3/21/94)		tRectOK? composite? and		{			% *** new test for not skewed and modulo 90 degree rotation			% *** wrapped in a stopped to intercept degenerate matrix errors			{				mark				0 1 dtransform atan cvi 90 mod 0 eq				1 0 dtransform atan cvi 90 mod 0 eq			} stopped			{				% error in atan				cleartomark			}			{				and exch pop				{					newpath					% *** (tile with rect blend\n) print					doRctBlend				}				{					doBlend				} ifelse			} ifelse		}		{			doBlend		} ifelse	} } ifelse% *** (exit linImg\n) printbd/doRctBlend{	gsave	/sInc 1 store	/nSamples bDataLen store	/bInc 1 bDataLen div store	/ubAxis 1 0 dtransform dUserSpace idtransform dup mul exch dup mul add sqrt store	/pChange ubAxis 0 eq	{		0	}	{		bDataLen ubAxis div	} ifelse	store	pChange .5 gt noImg not and dup /optimize? xs	{		% *** round result stored in nSamples		% *** must be integer since we use it to control repeat loop		% *** keep a minimum of 2 samples : if nSamples was 1		% *** we'd get a divide by zero error in calculating sInc		% *** 0 samples would make no sense		/nSamples ubAxis 2 div round cvi dup 1 le		{			pop 2		} if		store		/bInc 1 nSamples div store		/sInc bDataLen 1 sub nSamples 1 sub div store	} if	% *** push #0 for initial sampling index	0	nSamples	[	% *** copy the current sampling  index	/dup cvx	optimize?	{		/round cvx /cvi cvx	} if	/ndx /exch cvx /store cvx	bCFun%	Don't use /rectfill if _compositeSpotDevice is enabled 	/rectfill where dup	{		exch pop _compositeSpotDevice 1 ne and	} if	{		0 0 bInc 1 /rectfill cvx		}	{		0 0 /moveto cvx		bInc 0 /lineto cvx		bInc 1 /lineto cvx		0 1 /lineto cvx		/closepath cvx		/_fill_ cvx	} ifelse	bInc 0 /translate cvx	% *** add sampling increment to curent ndx value	sInc /add cvx	] cvx	bind	repeat	% *** pop off sampling index	pop	% turn off ncustomcolor mode	spotColor? {nsetcustomcolorend} if		grestore} bd/rdPrep{	/nSamples bDataLen dup 0 eq	{		pop 1	} if	store	/sInc -1 store	/bAxis rampPoint endPoint sub store	% *** made bInc negative here for consistency	/bInc bAxis bDataLen div neg store	/optimize? false store	tRectOK?	{		/ubAxis		bAxis 0 dtransform dUserSpace idtransform dup mul exch dup mul add sqrt		0 bAxis dtransform dUserSpace idtransform dup mul exch dup mul add sqrt		2 copy lt		{			exch		} if		pop store		/pChange ubAxis 0 eq		{			0		}		{			bDataLen ubAxis div		} ifelse		store		% added noImg condition so that radials always print in full res 		% w/ compatible gradients setting turned ON (bh 9/2/94)		pChange .5 gt noImg not and dup /optimize? xs		{			% *** round result stored in nSamples			% *** must be integer since we use it to control repeat loop			% *** keep a minimum of 2 samples : if nSamples was 1			% *** we'd get a divide by zero error in calculating sInc			% *** 0 samples would make no sense			/nSamples ubAxis 2 div round cvi dup 1 le			{				pop 2			} if			store			% *** removed adding 1 to nSamples here			/bInc bAxis nSamples div neg store			/sInc bDataLen 1 sub nSamples 1 sub div neg store		} if	} if	bHi?	{		/xBCInc xHi bAxis mul nSamples div store		/yBCInc yHi bAxis mul nSamples div store	} if} bd/rdBlend{	newpath	gsave	rdPrep	% push rampPoint for initial radius	rampPoint	% push bDataLen for initial sampling index	bDataLen 1 sub	nSamples	[	% *** duplicate working sampling index	/dup cvx	optimize?	{		/round cvx /cvi cvx	} if	/ndx /exch cvx /store cvx	bCFun	% *** changed to reflect extra variable on stack	0 0 3 /index cvx 0 360 /arc cvx /_fill_ cvx	% *** decrement radius	/exch cvx bInc /add cvx /exch cvx	% *** decrement sampling index	sInc /add cvx	bHi?	{		xBCInc yBCInc /translate cvx	} if	] cvx	bind	repeat	% *** pop off rampPoint and sampling index	pop pop	% turn off ncustomcolor mode	spotColor? {nsetcustomcolorend} if	grestore	pTState?	{		xHi bAxis mul yHi bAxis mul translate	} if} bd/Bh{	pop pop	% assume no hilite	/pTState? false store	2 copy 0 ne exch 0 ne or dup /bHi? xs	{		/yHi xs		/xHi xs		0 0	} if	pop pop} bd/BD{	inLine? not	{		] nColors cBType		] _bn cBName 3 -1 roll put	end} if} bd/Bn{1 add dictdup nullString null put/_bn xs} bd/Bd{Adobe_blend_AI5_vars begin	3 -1 roll dup nullString eq dup	{		setSSave	} if	/inLine? exch def	/cBName exch def	/nColors exch def	/cBType exch def} bd/Bb{	sSave null eq	{		Adobe_blend_AI5_vars begin		setSSave	} if	% enforce fill overprint semantics for white in gradients (bh 3/26/94)	composite?	{		/_fill /fill load store	}	{		/__fill /fill load store			/_fill			{				_of true eq				{					currentgray 1 ne					{						__fill					} if				}				{					__fill				} ifelse			} def	} ifelse	/fill	{	} def	} bd	/BB	{	/cBType xs	cleartomark cleartomark	cBType dup	bRender	% *** fix future problems before they fix you !	sSave dup type /savetype eq	{		restore 0	} if	pop	currentdict Adobe_blend_AI5_vars eq	{		end	} if	2 ne exch 0 gt and	{		2 eq		{			s		}		{			S		} ifelse	}	{		% must clear the path if it's a fill only		pop newpath	} ifelse} bdcurrentdict readonly popendenddefaultpacking setpacking%%EndResource% ------------------------------------------------------%%BeginProcSet: Adobe_ColorImage_AI6 1.0 0% ColorImage Emulation and Separation Code for Grayscale, RGB and CMYK images% Version 1.0 12/25/95% Copyright (C) 1995-96% Adobe Systems Incorporated% All Rights Reserved% ------------------------------------------------------userdict /Adobe_ColorImage_AI6 known not{	userdict /Adobe_ColorImage_AI6 17 dict put } ifuserdict /Adobe_ColorImage_AI6 get begin% ------------------------------------------------------% Routine Overview% %	String Iterators%		WalkRGBString (given a single source string, convert each pixel to cmyk and call a proc)%		WalkCMYKString (given a single source string, get the components and call a proc)% %	Level1 Emulator Routines%		StuffRGBIntoGrayString%		RGBToGrayImageProc%		StuffCMYKIntoGrayString %		CMYKToGrayImageProc %		ColorImageCompositeEmulator % %	ColorImage CMYK Separation Hacks (For [Applications] that only support planar images)%		CMYKToSeparatedCMYKImageProc% %	ColorImage and Utility Routines.%		FourEqual%		TestPlateIndex%		colorimage% % ------------------------------------------------------	/initialize{ 	Adobe_ColorImage_AI6 begin	Adobe_ColorImage_AI6	{		dup type /arraytype eq		{			dup xcheck			{				bind			} if		} if		pop pop	} forall} def/terminate { end } defcurrentdict /Adobe_ColorImage_AI6_Vars known not{	/Adobe_ColorImage_AI6_Vars 14 dict def} ifAdobe_ColorImage_AI6_Vars begin	/channelcount 0 def	/sourcecount 0 def	/sourcearray 4 array def	/plateindex -1 def	/XIMask 0 def	/XIBinary 0 def	/XIChannelCount 0 def	/XIBitsPerPixel 0 def	/XIImageHeight 0 def	/XIImageWidth 0 def	/XIImageMatrix null def	/XIBuffer null def	/XIDataProc null defend/WalkRGBString null def/WalkCMYKString null def/StuffRGBIntoGrayString null def/RGBToGrayImageProc null def/StuffCMYKIntoGrayString null def/CMYKToGrayImageProc null def/ColorImageCompositeEmulator null def/SeparateCMYKImageProc null def/FourEqual null def/TestPlateIndex null def% define _colorimage if it doesn't already existcurrentdict /_colorimage known not{	/colorimage where	{		% sourcedictionary (systemdict or a separation proc redefinition)		/colorimage get /_colorimage exch def	}	{		/_colorimage null def	} ifelse} if/_currenttransfer systemdict /currenttransfer get def/colorimage null def/XI null def% ------------------------------------------------------% rgb proc out --WalkRGBString--% ------------------------------------------------------/WalkRGBString{	% rgb proc out	0 3 index	% rgb proc out outindex rgb	dup length 1 sub 0 3 3 -1 roll	{		% rgb proc out outindex rgb index		3 getinterval { } forall		% call the stuff proc		% rgb proc out outindex r g b		5 index exec		% push rgb for the next loop iteration		% rgb proc out outindex		3 index		% rgb proc out outindex rgb	} for		% clean up the stack	% rgb proc out outindex rgb	 5 { pop } repeat} def% ------------------------------------------------------% cmyk proc gray --WalkCMYKString--% ------------------------------------------------------/WalkCMYKString{	% cmyk proc gray	0 3 index	% cmyk proc gray grayindex cmyk	dup length 1 sub 0 4 3 -1 roll	{		% cmyk proc gray grayindex cmyk index		4 getinterval { } forall				% cmyk proc gray grayindex c m y k		6 index exec				% cmyk proc gray grayindex		3 index				% cmyk proc gray grayindex cmyk	} for		% clean up the stack	% cmyk proc gray grayindex cmyk	5 { pop } repeat	} def% ------------------------------------------------------% gray grayindex r g b --StuffRGBIntoGrayString-- gray grayindex% ------------------------------------------------------/StuffRGBIntoGrayString{	% gray grayindex r g b	.11 mul exch		% gray grayindex r bk g	.59 mul add exch		% gray grayindex bkgk r	.3 mul add		% gray grayindex k	cvi 3 copy put		% gray grayindex k	pop 1 add} def% ------------------------------------------------------% --RGBToGrayImageProc-- string% ------------------------------------------------------/RGBToGrayImageProc{		Adobe_ColorImage_AI6_Vars begin			% call the source proc to get the chunky rgb string		sourcearray 0 get exec		% make a grayscale string of the same pixel count (ouch, pull me out of this loop)		% rgb		dup length 3 idiv string		% roll off a copy of the gray string		% rgb gray		dup 3 1 roll 				% push the stuff proc that we want called by WalkRGBString		% gray rgb gray		/StuffRGBIntoGrayString load exch		% call the rgb conversion iterator		% gray rgb proc gray		WalkRGBString		% return the gray string		% gray		end} def% ------------------------------------------------------% gray grayindex c m y k --StuffCMYKIntoGrayString-- gray grayindex% ------------------------------------------------------/StuffCMYKIntoGrayString{	% gray grayindex c m y k	exch .11 mul add		% gray grayindex c m yk	exch .59 mul add		% gray grayindex c mkyk	exch .3 mul add		% pin k to 255	% gray gray index k	dup 255 gt { pop 255 } if		% gray grayindex k	255 exch sub cvi 3 copy put		% gray grayindex k	pop 1 add} def% ------------------------------------------------------% --CMYKToGrayImageProc-- string% ------------------------------------------------------/CMYKToGrayImageProc{		Adobe_ColorImage_AI6_Vars begin		% call the source proc to get the chunky cmyk string		sourcearray 0 get exec		% make a grayscale string of the same pixel count (ouch, pull me out of this loop)		% cmyk		dup length 4 idiv string		% roll off a copy of the gray string		% cmyk gray		dup 3 1 roll 				% push the stuff proc that we want called by WalkCMYKString		% gray cmyk gray		/StuffCMYKIntoGrayString load exch		% call the cmyk iterator		% gray cmyk proc gray		WalkCMYKString		% return the gray string		% gray	end} def% ------------------------------------------------------% width height bitsperpixel matrix firstsource...lastsource multiplesources channelcount --ColorImageCompositeEmulator--% ------------------------------------------------------/ColorImageCompositeEmulator{	% Channelcount is already saved in Adobe_ColorImage_AI6_Vars. Our data is always in chunky form so punt if someone	% calls colorimage on a level 1 device with planar data.	% channelcount and multiplesources are already saved in Adobe_ColorImage_AI6_Vars. The image operator isn't going to use them.	pop true eq	{		% pop off the parameters and return		Adobe_ColorImage_AI6_Vars /sourcecount get 5 add { pop } repeat	}	{		Adobe_ColorImage_AI6_Vars /channelcount get 1 ne		{			Adobe_ColorImage_AI6_Vars begin				% save off the original chunky source function				sourcearray 0 3 -1 roll put							% push the appropriate cover proc				channelcount 3 eq 				{ 					/RGBToGrayImageProc 				}				{ 					/CMYKToGrayImageProc				} ifelse				load			end		} if		image	} ifelse} def% ------------------------------------------------------% --SeparateCMYKImageProc-- string% ------------------------------------------------------/SeparateCMYKImageProc{		Adobe_ColorImage_AI6_Vars begin		sourcecount 0 ne		{			% planar case: call the source proc for the current plate and return its result			sourcearray plateindex get exec		}		{						% call the source proc to get the chunky cmyk string			sourcearray 0 get exec						% make a grayscale string of the same pixel count (ouch, pull me out of this loop)			% cmyk			dup length 4 idiv string						% cmyk			0 2 index						% cmyk gray grayindex cmyk			plateindex 4 2 index length 1 sub			{				% cmyk gray grayindex cmyk channelindex				get 255 exch sub								% cmyk gray grayindex grayvalue				3 copy put pop 1 add								% cmyk gray grayindex				2 index			} for			% return the gray string			% cmyk gray grayindex cmyk			pop pop exch pop		} ifelse	end} def	% ------------------------------------------------------% s1 s2 s3 s4 c1 c2 c3 c4 --FourEqual--% ------------------------------------------------------/FourEqual{	% s1 s2 s3 s4 c1 c2 c3 c4	4 index ne	{		pop pop pop false	}	{		% s1 s2 s3 s4 c1 c2 c3		4 index ne		{			pop pop false		}		{			% s1 s2 s3 s4 c1 c2			4 index ne			{				pop false			}			{				% s1 s2 s3 s4 c1				4 index eq			} ifelse		} ifelse	} ifelse} def% ------------------------------------------------------%  --TestPlateIndex-- plateindex% ------------------------------------------------------/TestPlateIndex{	Adobe_ColorImage_AI6_Vars begin		% assume we're not separating		/plateindex -1 def		/setcmykcolor where		{			pop			gsave			1 0 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub			0 1 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub			0 0 1 0 setcmykcolor systemdict /currentgray get exec 1 exch sub			0 0 0 1 setcmykcolor systemdict /currentgray get exec 1 exch sub			grestore			% cyan plate?			1 0 0 0 FourEqual 			{ 				/plateindex 0 def			}			{				% magenta plate?				0 1 0 0 FourEqual				{ 					/plateindex 1 def				}				{					% yellow plate?					0 0 1 0 FourEqual					{						/plateindex 2 def					}					{						% black plate						0 0 0 1 FourEqual						{ 							/plateindex 3 def						}						{							0 0 0 0 FourEqual							{								/plateindex 5 def							} if						} ifelse					} ifelse				} ifelse			} ifelse			pop pop pop pop		} if		plateindex	end} def% ------------------------------------------------------% width height bitsperpixel matrix firstsource...lastsource multiplesources channelcount --colorimage--% ------------------------------------------------------/colorimage{	Adobe_ColorImage_AI6_Vars begin		/channelcount 1 index def		/sourcecount 2 index 1 eq { channelcount 1 sub } { 0 } ifelse def		% setup for following if statement		4 sourcecount add index dup 		8 eq exch 1 eq or not	end		% is this not 1 or 8 bit?	{		% Call the original proc if the image is at a weird bit depth. This will display a composite if we're separating, but too bad.		/_colorimage load null ne		{			% call the original (they probably punt if we're separating)			_colorimage		}		{			% pop off the parameters and return			Adobe_ColorImage_AI6_Vars /sourcecount get			7 add { pop } repeat		} ifelse	}	{		% Call the saved colorimage operator if this an rgb, we're printing a composite or we're separating		% an image to a custom plate. The last case assumes that the separation procs surrounding us		% take care of punching out		dup 3 eq		TestPlateIndex		dup -1 eq exch 5 eq or or		{			% Call the colorimage emulator if we're printing to a level 1 device			/_colorimage load null eq			{				ColorImageCompositeEmulator			}			{				% call image if this is a grayscale so that Quark doesn't die on custom plates				dup 1 eq				{					pop pop image				}				{					% draw to the null device if we're on a custom plate					Adobe_ColorImage_AI6_Vars /plateindex get 5 eq					{						gsave												% stolen from PhotoShop						0 _currenttransfer exec						1 _currenttransfer exec						eq						{ 0 _currenttransfer exec 0.5 lt }						{ 0 _currenttransfer exec 1 _currenttransfer exec gt } ifelse												% push the appropriate transfer proc (first case is negative						% second case is positive) and call settransfer						{ { pop 0 } } { { pop 1 } } ifelse						systemdict /settransfer get exec					} if										_colorimage										% restore from the null device if necessary					Adobe_ColorImage_AI6_Vars /plateindex get 5 eq					{						grestore					} if				} ifelse			} ifelse		}		{			% Are we separating a grayscale image?			dup 1 eq			{				% let the surrounding separation procset handle the separation				pop pop				image			}			{				% pop channelcount and multiplesources since they're not used by the image operator				pop pop				% Prepare to call the image operator with a cover proc				Adobe_ColorImage_AI6_Vars begin					% save off the source procs for our cover proc					% width height bitsperpixel matrix firstsource...lastsource					sourcecount -1 0					{									% width height bitsperpixel matrix firstsource...lastsource index						exch sourcearray 3 1 roll put					} for					/SeparateCMYKImageProc load				end				% bypass the separation procset since some applications don't handle chunky and the				% old separator doesn't handle colorimage				systemdict /image get exec			} ifelse		} ifelse	} ifelse} def% ------------------------------------------------------% --XI--% ------------------------------------------------------/XI{	Adobe_ColorImage_AI6_Vars begin		gsave		/XIMask exch 0 ne def		/XIBinary exch 0 ne def		pop		pop		/XIChannelCount exch def		/XIBitsPerPixel exch def		/XIImageHeight exch def		/XIImageWidth exch def		pop pop pop pop		/XIImageMatrix exch def				XIBitsPerPixel 1 eq		{			XIImageWidth 8 div ceiling cvi		}		{			XIImageWidth XIChannelCount mul		} ifelse		/XIBuffer exch string def				XIBinary		{			/XIDataProc { currentfile XIBuffer readstring pop } def			% skip the %BeginBinary comment			currentfile 128 string readline pop pop		}		{			/XIDataProc { currentfile XIBuffer readhexstring pop } def		} ifelse				0 0 moveto		XIImageMatrix concat		XIImageWidth XIImageHeight scale				XIMask		{			XIImageWidth XIImageHeight			false			[ XIImageWidth 0 0 XIImageHeight neg 0 0 ]			/XIDataProc load						% synch the PostScript fill with Illustrator's notion of the current fill			/_lp /null ddef			_fc			/_lp /imagemask ddef						imagemask		}		{			XIImageWidth XIImageHeight			XIBitsPerPixel			[ XIImageWidth 0 0 XIImageHeight neg 0 0 ]			/XIDataProc load						% call image if passed grayscale or bitmap data. Some applications			% die if colorimage is called with gray data.			XIChannelCount 1 eq			{				% Some applications refuse to separate a grayscale image to the black plate if				% the currentgray is white. Hack around.								gsave				0 setgray								image								grestore			}			{				false				XIChannelCount				colorimage			} ifelse		} ifelse		grestore	end} def	end%%EndProcSet% ------------------------------------------------------%%BeginResource: procset Adobe_Illustrator_AI5 1.1 0%%Title: (Adobe Illustrator (R) Version 5.0 Full Prolog)%%Version: 1.1 0%%CreationDate: (3/7/1994) ()%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)% ------------------------------------------------------currentpacking true setpacking% 71 vars, but leave slack of 10 entries for custom Postscript fragmentsuserdict /Adobe_Illustrator_AI5_vars 81 dict dup beginput% paint operands/_eo false def/_lp /none def/_pf{} def	% paint fill/_ps{} def	% paint stroke/_psf{} def	% paint string fill/_pss{} def	% paint string stroke/_pjsf{} def	% paint justified string fill/_pjss{} def	% paint justified string stroke/_pola 0 def/_doClip 0 def% paint operators/cf currentflat def	% - cf flatness% typography operands/_tm matrix def/_renderStart[/e0 /r0 /a0 /o0 /e1 /r1 /a1 /i0] def/_renderEnd[null null null null /i1 /i1 /i1 /i1] def/_render -1 def/_rise 0 def/_ax 0 def	% x character spacing	(_ax, _ay, _cx, _cy follows awidthshow naming convention)/_ay 0 def	% y character spacing/_cx 0 def	% x word spacing/_cy 0 def	% y word spacing/_leading[0 0] def/_ctm matrix def/_mtx matrix def/_sp 16#020 def/_hyphen (-) def/_fScl 0 def/_cnt 0 def/_hs 1 def/_nativeEncoding 0 def/_useNativeEncoding 0 def/_tempEncode 0 def/_pntr 0 def/_tDict 2 dict def/_wv 0 def% typography operators/Tx{} def/Tj{} def% compound path operators/CRender{} def% printing/_AI3_savepage{} def% color operands/_gf null def/_cf 4 array def/_if null def/_of false def/_fc{} def/_gs null def/_cs 4 array def/_is null def/_os false def/_sc{} def% pattern operands/_pd 1 dict def/_ed 15 dict def/_pm matrix def/_fm null def/_fd null def/_fdd null def/_sm null def/_sd null def/_sdd null def/_i null def% discard variables (12 total)/discardSave null def	% holds save used in discard loop/buffer 256 string def	% line buffer string : assume 256 chars/line/beginString null def	% begin delimiter/endString null def	% end delimiter/endStringLength null def	% holds buffer size for reading by byte technique/layerCnt 1 def	% internal variables for discard loop/layerCount 1 def/perCent (%) 0 get def/perCentSeen? false def/newBuff null def/newBuffButFirst null def/newBuffLast null def% variable for doing clipping without rendering/clipForward? false def% end the vars dictionaryend% =========================================userdict /Adobe_Illustrator_AI5 known not {	userdict /Adobe_Illustrator_AI5 91 dict put} ifuserdict /Adobe_Illustrator_AI5 get begin% initialization/initialize	% - initialize -{	% pushing main on the stack	Adobe_Illustrator_AI5 dup begin	% push the vars dictionary	Adobe_Illustrator_AI5_vars begin	% at this point the main and vars dictionaries	% are in the state we wish them to be	% on exit from the initialize call	% bind the procedures in the discard dictionary	discardDict	{		bind pop pop	} forall	% begin the nc dictionary	dup /nc get begin	% bind the procs in main	{		% added a test for type = operatortype so procedures like Ln can be defined as an alias for 'pop		dup xcheck 1 index type /operatortype ne and		{			bind		} if		pop pop	} forall	% turn off 'nc	end	newpath	% on exit we have main and vars on top of dict stack} def/terminate	% - terminate -{	end	end} def% definition operators/_	% - _ nullnull def/ddef	% key value ddef -{	Adobe_Illustrator_AI5_vars 3 1 roll put} def/xput	% key value literal xput -{	dup load dup length exch maxlength eq	{		dup dup load dup		length 2 mul dict copy def	} if	load begin	def	end} def/npop	% integer npop -{	{		pop	} repeat} def% marking operators/sw	% ax ay string sw x y{	dup length exch stringwidth	exch 5 -1 roll 3 index mul add	4 1 roll 3 1 roll mul add} def/swj	% cx cy fillchar ax ay string swj x y{	dup 4 1 roll	dup length exch stringwidth	exch 5 -1 roll 3 index mul add	4 1 roll 3 1 roll mul add	6 2 roll /_cnt 0 ddef	{		1 index eq		{			/_cnt _cnt 1 add ddef		} if	} forall	pop	exch _cnt mul exch _cnt mul 2 index add 4 1 roll 2 index add 4 1 roll pop pop} def/ss	% ax ay string matrix ss -{	4 1 roll	{		% matrix ax ay char 0 0 {proc} -		2 npop		(0) exch 2 copy 0 exch put pop		gsave		false charpath currentpoint		4 index setmatrix		stroke		grestore		moveto		2 copy rmoveto	} exch cshow	3 npop} def/jss	% cx cy fillchar ax ay string matrix jss -{	4 1 roll	{		% cx cy fillchar matrix ax ay char 0 0 {proc} -   		2 npop		(0) exch 2 copy 0 exch put		gsave		_sp eq		{			exch 6 index 6 index 6 index 5 -1 roll widthshow			currentpoint		}		{			false charpath currentpoint			4 index setmatrix stroke		} ifelse		grestore		moveto		2 copy rmoveto	} exch cshow	6 npop} def% path operators/sp	% ax ay string sp -{	{		2 npop (0) exch		2 copy 0 exch put pop		false charpath		2 copy rmoveto	} exch cshow	2 npop} def/jsp	% cx cy fillchar ax ay string jsp -{	{		% cx cy fillchar ax ay char 0 0 {proc} -		2 npop		(0) exch 2 copy 0 exch put		_sp eq		{			exch 5 index 5 index 5 index 5 -1 roll widthshow		}		{			false charpath		} ifelse		2 copy rmoveto	} exch cshow	5 npop} def% path construction operators/pl	% x y pl x y{	transform	0.25 sub round 0.25 add exch	0.25 sub round 0.25 add exch	itransform} def/setstrokeadjust where{	pop true setstrokeadjust	/c	% x1 y1 x2 y2 x3 y3 c -	{		curveto	} def	/C	/c load def	/v	% x2 y2 x3 y3 v -	{		currentpoint 6 2 roll curveto	} def	/V	/v load def	/y	% x1 y1 x2 y2 y -	{		2 copy curveto	} def	/Y	/y load def	/l	% x y l -	{		lineto	} def	/L	/l load def	/m	% x y m -	{		moveto	} def}{	% else	/c	{		pl curveto	} def	/C	/c load def	/v	{		currentpoint 6 2 roll pl curveto	} def	/V	/v load def	/y	{		pl 2 copy curveto	} def	/Y	/y load def	/l	{		pl lineto	} def	/L	/l load def	/m	{		pl moveto	} def} ifelse% graphic state operators/d	% array phase d -{	setdash} def/cf{} def	% - cf flatness/i	% flatness i -{	dup 0 eq	{		pop cf	} if	setflat} def/j	% linejoin j -{	setlinejoin} def/J	% linecap J -{	setlinecap} def/M	% miterlimit M -{	setmiterlimit} def/w	% linewidth w -{	setlinewidth} def% path painting operators/XR	% flag XR -{	0 ne	/_eo exch ddef} def/H	% - H -{} def/h	% - h -{	closepath} def/N	% - N -{	_pola 0 eq	{		_doClip 1 eq		{			_eo {eoclip} {clip} ifelse /_doClip 0 ddef		} if		newpath	}	{		/CRender		{			N		} ddef	} ifelse} def/n	% - n -{	N} def/F	% - F -{	_pola 0 eq	{		_doClip 1 eq		{			gsave _pf grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _fc			/_doClip 0 ddef		}		{			_pf		} ifelse	}	{		/CRender		{			F		} ddef	} ifelse} def/f	% - f -{	closepath	F} def/S	% - S -{	_pola 0 eq	{		_doClip 1 eq		{			gsave _ps grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc			/_doClip 0 ddef		}		{			_ps		} ifelse	}	{		/CRender		{			S		} ddef	} ifelse} def/s	% - s -{	closepath	S} def/B	% - B -{	_pola 0 eq	{		_doClip 1 eq	% F clears _doClip		gsave F grestore		{			gsave S grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc			/_doClip 0 ddef		}		{			S		} ifelse	}	{		/CRender		{			B		} ddef	} ifelse} def/b	% - b -{	closepath	B} def/W	% - W -{	/_doClip 1 ddef} def/*	% - [string] * -{	count 0 ne	{		dup type /stringtype eq		{			pop		} if	} if	% used to call newpath only if _polo was 0; now newpath is called unconditionally (bh 3/24/94)	newpath} def% group operators/u	% - u -{} def/U	% - U -{} def/q	% - q -{	_pola 0 eq	{		gsave	} if} def/Q	% - Q -{	_pola 0 eq	{		grestore	} if} def/*u	% - *u -{	_pola 1 add /_pola exch ddef} def/*U	% - *U -{	_pola 1 sub /_pola exch ddef	_pola 0 eq	{		CRender	} if} def/D	% polarized D -{	pop} def/*w	% - *w -{} def/*W	% - *W -{} def% place operators/`	% matrix llx lly urx ury string ` -{	/_i save ddef% * special case of clipping forward without rendering	% use 'nulldevice if true	clipForward?	{		nulldevice	} if	6 1 roll 4 npop	concat pop	userdict begin	/showpage	{	} def	0 setgray	0 setlinecap	1 setlinewidth	0 setlinejoin	10 setmiterlimit	[] 0 setdash	/setstrokeadjust where {pop false setstrokeadjust} if	newpath	0 setgray	false setoverprint} def/~	% - ~ -{	end	_i restore} def% color operators/O	% flag O -{	0 ne	/_of exch ddef	/_lp /none ddef} def/R	% flag R -{	0 ne	/_os exch ddef	/_lp /none ddef} def/g	% gray g -{	/_gf exch ddef	/_fc	{		_lp /fill ne		{			_of setoverprint			_gf setgray			/_lp /fill ddef		} if	} ddef	/_pf	{		_fc		_eo {eofill} {fill} ifelse	} ddef	/_psf	{		_fc		ashow	} ddef	/_pjsf	{		_fc		awidthshow	} ddef	/_lp /none ddef} def/G	% gray G -{	/_gs exch ddef	/_sc	{		_lp /stroke ne		{			_os setoverprint			_gs setgray			/_lp /stroke ddef		} if	} ddef	/_ps	{		_sc		stroke	} ddef	/_pss	{		_sc		ss	} ddef	/_pjss	{		_sc		jss	} ddef	/_lp /none ddef} def/k	% cyan magenta yellow black k -{	_cf astore pop	/_fc	{		_lp /fill ne		{			_of setoverprint			_cf aload pop setcmykcolor			/_lp /fill ddef		} if	} ddef	/_pf	{		_fc		_eo {eofill} {fill} ifelse	} ddef	/_psf	{		_fc		ashow	} ddef	/_pjsf	{		_fc		awidthshow	} ddef	/_lp /none ddef} def/K	% cyan magenta yellow black K -{	_cs astore pop	/_sc	{		_lp /stroke ne		{			_os setoverprint			_cs aload pop setcmykcolor			/_lp /stroke ddef		} if	} ddef	/_ps	{		_sc		stroke	} ddef	/_pss	{		_sc		ss	} ddef	/_pjss	{		_sc		jss	} ddef	/_lp /none ddef} def/x	% cyan magenta yellow black name gray x -{	/_gf exch ddef	findcmykcustomcolor	/_if exch ddef	/_fc	{		_lp /fill ne		{			_of setoverprint			_if _gf 1 exch sub setcustomcolor			/_lp /fill ddef		} if	} ddef	/_pf	{		_fc		_eo {eofill} {fill} ifelse	} ddef	/_psf	{		_fc		ashow	} ddef	/_pjsf	{		_fc		awidthshow	} ddef	/_lp /none ddef} def/X	% cyan magenta yellow black name gray X -{	/_gs exch ddef	findcmykcustomcolor	/_is exch ddef	/_sc	{		_lp /stroke ne		{			_os setoverprint			_is _gs 1 exch sub setcustomcolor			/_lp /stroke ddef		} if	} ddef	/_ps	{		_sc		stroke	} ddef	/_pss	{		_sc		ss	} ddef	/_pjss	{		_sc		jss	} ddef	/_lp /none ddef} def% locked object operator/A	% value A -{	pop} def% annotate page operator/annotatepage{userdict /annotatepage 2 copy known {get exec} {pop pop} ifelse} def% object tag operator% joe holt November 20, 1994% /name (value) XT/XT {	pop pop} def% begin layer PostScript implementation% general purpose discard loop% works on early level 1 (v.23, v.38) PostScript printers% version 0.02 04/03/93% Bill Woodruff% constraints :% if nested discards must be handled% then the begin and end delimiting% strings must be of equal length% arguments% #nestingFlag% #nestingFlag = 0  				no nesting% #nestingFlag = 1  				nesting% non-nested case% note : since the non-nested case is invoked% after the ocurrence of a beginning string% we only have to look for the ending string% it is not necessary to specify a beginning string% 0 (endString) % nested case% (beginString) 1 (endString) % the discard procedure is defined in the main dictionary% it turns the discard dictionary on to execute the discard function/discard{	% test for version, hash a key	% get and execute the discard procedure from dictionary	% execute it in a stopped context so we can bail with 'stop	% wrap it in a save so we don't have to reset variables	save /discardSave exch store	discardDict begin	/endString exch store	gt38?	{		2 add	} if	load	stopped	pop	end	discardSave restore} bind def% build the discard dictionary which will contain only proceduresuserdict /discardDict 7 dict dup beginput% pre 38 initialization/pre38Initialize{	% used as buffer size for reading by byte technique		/endStringLength endString length store	/newBuff buffer 0 endStringLength getinterval store	%	new buffer equal in length to end string	/newBuffButFirst newBuff 1 endStringLength 1 sub getinterval store	%	pointer to from 2nd to last char in new buffer	/newBuffLast newBuff endStringLength 1 sub 1 getinterval store	%	pointer to last char in new buffer} def% for <=38	/shiftBuffer{	% shift last chars of newBuff to start of newBuff	newBuff 0 newBuffButFirst putinterval	% new character into last byte of newBuff	newBuffLast 0	currentfile read not	{	stop	} if	put} def% discard procedures% no nesting, older ps0{	pre38Initialize	mark	% fill the buffer	currentfile newBuff readstring exch pop	{		{			newBuff endString eq			{				cleartomark stop			} if			shiftBuffer		} loop	}	{	stop	} ifelse} def% nesting, older ps1{	pre38Initialize	/beginString exch store	mark	currentfile newBuff readstring exch pop	{		{			newBuff beginString eq			{				/layerCount dup load 1 add store			}			{				newBuff endString eq				{					/layerCount dup load 1 sub store					layerCount 0 eq					{						cleartomark stop					} if				} if			} ifelse			shiftBuffer		} loop	} if} def% no nesting, newer ps2{	mark	{		% read a line : exit if end of file reached		currentfile buffer readline not		{		stop		} if		% end of layer ?		endString eq		{			cleartomark stop		} if	} loop} def% nesting, newer ps3{	/beginString exch store	/layerCnt 1 store	mark	{		% read a line : exit if end of file reached		currentfile buffer readline not		{		stop		} if		% start of layer ?		dup beginString eq		{			% update layer counter			pop /layerCnt dup load 1 add store		}		{			% end of layer ?			endString eq			{				% stop if we're not nested				layerCnt 1 eq				{					cleartomark stop				}				{					% nested : decrement layer counter					/layerCnt dup load 1 sub store				} ifelse			} if		} ifelse	} loop} def% end discard dictionaryend% define the dictionary for clipping without renderinguserdict /clipRenderOff 15 dict dup beginput% flag for marking this dictionary as active% so we can test in /` and wrap placed% elements in nulldevice% /clipForward? true def% re-define rendering primitives to clip and newpath% based on value of /_doClip flag{	/n /N /s /S /f /F /b /B}{	{		_doClip 1 eq		{			/_doClip 0 ddef _eo {eoclip} {clip} ifelse		} if		newpath	} def} forall% modify 'Tr so Tj and Tx are never set up by% the calls to 'a0, 'e0, etc./Tr /pop load def% special case of 'cshow ?% is so, we'll have to overload toplevels% /patternashow /patternawidthshow% /patternashowstroke% /patternawidthshowstroke% /ss /jss /sp /jsp% perhaps we can bracket out patterns at a higher level ?% for example, by modifying 'E to pop off its parameters% call to 'show in 'patternpath ?% calls to 'ashow in '_psf ?% calls to 'awidthshow in '_pjsf ?% calls to 'widthshow in '_jss and '_jsp ?% disable gradient operators/Bb {} def/BB /pop load def/Bg {12 npop} def/Bm {6 npop} def/Bc /Bm load def/Bh {4 npop} def% end dictionary for clipping without renderingend/Lb	% visible preview enabled printing dimmed masks colorIndex red green blue  ==> Lb{	4 npop	6 1 roll	pop	4 1 roll	pop pop pop	% #masks #printing 	% assume that	% masks = 1 masks forward, masks = 0 no masking or only local masking		% do the right thing for printing and masking layer	0 eq	{		% non-printing layer		0 eq		{			% no masking forward from this layer			% nested discard call			(%AI5_BeginLayer) 1 (%AI5_EndLayer--) discard		}		{			% masking forward from this layer			% no printing, but clip path must survive						% set the clipForward? flag in the vars dict			/clipForward? true def						% redefine Tx and Tj in the vars dict			/Tx /pop load def			/Tj /pop load def						% turn on the no rendering dictionary			currentdict end clipRenderOff begin begin		} ifelse	}	{		% printing layer		% encapsulate layer with 'save		% only if there is no masking forward		0 eq		{			save /discardSave exch store		} if	} ifelse} bind def% end layer :% assume that if discardSave is non-null% then the layer was bracketed by 'save...restore% else we must test for clipping forward/LB	% ==> Lb ==> .....{	discardSave dup null ne	{		% undo the save		restore	}	{		pop		clipForward?		{			% assume dictionary stack :			%		vars						%		clipRenderOff						%		main			currentdict			end			end			begin			% dictionary stack :			%		vars						%		main								/clipForward? false ddef		} if	} ifelse} bind def% begin palette discard% assume no nesting/Pb	% topLeftCell selected Pb -{	pop pop	% non nested discard	0 (%AI5_EndPalette) discard} bind def% other type of discard% assume no nesting/Np{	0 (%AI5_End_NonPrinting--) discard} bind def% express layer name/Ln /pop load def	% ==> Ln ==> .....% path center-point flag operator/Ap	% value Ap -/pop load def% device-independent flatness/Ar{	72 exch div	0 dtransform dup mul exch dup mul add sqrt	dup 1 lt	{		pop 1	} if	setflat} def% multi-layer clipping/Mb{	q} def/Md{} def/MB{	Q} def% null color operators/nc 3 dict defnc begin/setgray	% gray setgray -{	pop} bind def/setcmykcolor	% cyan magenta yellow black setcmykcolor -{	4 npop} bind def/setcustomcolor	% object tint setcustomcolor -{	2 npop} bind def% exit 'nc dictionarycurrentdict readonly popend% exit main dictionary% currentdict readonly popendsetpacking%%EndResource%%EndProlog%%BeginSetupAdobe_level2_AI5 /initialize get execAdobe_screens_AI5 /initialize get execAdobe_Illustrator_AI5_vars Adobe_Illustrator_AI5 Adobe_blend_AI5 /initialize get execAdobe_ColorImage_AI6 /initialize get execAdobe_Illustrator_AI5 /initialize get exec1 Bn%AI5_BeginGradient: ( 3)( 3) 0 6 Bd[0<1A1918181717161615151414131312121110100F0F0E0E0D0D0C0C0B0B0A0A090908070706060505040403030202010100><302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>01 %_Br0<212121212121202020202020201F1F1F1F1F1F1F1F1E1E1E1E1E1E1E1E1D1D1D1D1D1D1D1D1C1C1C1C1C1C1C1C1B1B1B1B1B1B1B1B1A1A1A1A1A1A1A1A><6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3A39383736353433323130>01 %_Br0<313130302F2E2D2C2C2B2A29282727262524232221><7F7F7E7D7C7C7B7A797877767574737271706F6E6D>01 %_Br0<42424241414040403F3F3E3E3E3D3D3C3C3C3B3B3A3A3A393939383837373736363535353434333333323231><ABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A8988878684838281807F>01 %_Br0<57575757575757575757575757575757575757575757575757575757575757575757575757575757575757575757575757575757575757575756565656565656565656565656565656565656565656565656565656565656565656565555555555555555555555555555555555545454545454545454545453535353535353535352525252525252525151515151515150505050504F4F4F4F4F4F4E4E4E4E4E4D4D4D4D4C4C4C4C4B4B4B4B4A4A4A4A49494948484848474747464646454545444443434342><FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFDFDFDFDFDFDFDFDFDFDFCFCFCFCFCFCFCFBFBFBFBFBFBFAFAFAFAFAF9F9F9F9F8F8F8F8F7F7F7F7F6F6F6F5F5F5F4F4F4F3F3F2F2F2F1F1F0F0F0EFEFEEEEEDEDECEBEBEAEAE9E9E8E7E7E6E5E5E4E3E3E2E1E0E0DFDEDDDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C6C5C4C3C2C0BFBEBCBBBAB8B7B5B4B3B1B0AEACAB>01 %_Br[1 0 50 100 %_Bs0 0.1 0.19 0 1 50 70 %_Bs0 0.13 0.4264 0 1 50 59 %_Bs0 0.194 0.4998 0 1 54 45 %_Bs0 0.26 0.67 0 1 50 32 %_Bs0 0.34 1 0 1 83 0 %_BsBD%AI5_EndGradient%AI5_Begin_NonPrintingNp8 Bn%AI5_BeginGradient: (Black & White)(Black & White) 0 7 Bd[<00020406080A0C0E11121416181A1C1E2022242628292B2D2F31333436383A3B3D3F4042444547494A4C4D4F5152545557585A5B5D5E606163646567686A6B6C6E6F70727374767778797B7C7D7E8081828384868788898A8B8C8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9A9AAABACADAEAFAFB0B1B2B3B4B4B5B6B7B7B8B9BABABBBCBDBDBEBFC0C0C1C2C2C3C4C4C5C6C6C7C7C8C9C9CACBCBCCCCCDCDCECFCFD0D0D1D1D2D2D3D3D4D4D5D5D6D6D7D7D8D8D9D9DADADBDBDCDCDCDDDDDEDEDEDFDFE0E0E0E1E1E2E2E2E3E3E3E4E4E5E5E5E6E6E6E7E7E7E8E8E8E8E9E9E9EAEAEAEAEBEBEBECECECECEDEDEDEDEEEEEEEEEFEFEFEFF0F0F0F0F0F1F1F1F1F1F2F2F2F2F2F3F3F3F3F3F4F4F4F4F4F4F5F5F5F5F5F5F6F6F6F6F6F6F6F7F7F7F7F7F7F7F7F8F8F8F8F8F8F8F8F9F9F9F9F9F9F9F9F9FAFAFAFAFAFAFAFAFAFAFAFBFBFBFBFBFBFBFBFBFBFBFBFBFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFCFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF>0 %_Br<91908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>0 %_Br<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291>0 %_Br<9495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF>0 %_Br<000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F5051535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F9091929394>0 %_Br<FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFDFCFCFCFCFCFCFCFCFCFCFCFCFCFCFBFBFBFBFBFBFBFBFBFBFBFBFAFAFAFAFAFAFAFAFAFAF9F9F9F9F9F9F9F9F9F8F8F8F8F8F8F8F8F7F7F7F7F7F7F7F6F6F6F6F6F6F6F5F5F5F5F5F5F5F4F4F4F4F4F4F3F3F3F3F3F3F2F2F2F2F2F2F1F1F1F1F1F0F0F0F0F0EFEFEFEFEFEEEEEEEEEEEDEDEDEDECECECECECEBEBEBEBEAEAEAEAE9E9E9E9E9E8E8E8E8E7E7E7E6E6E6E6E5E5E5E5E4E4E4E4E3E3E3E2E2E2E2E1E1E1E0E0E0DFDFDFDEDEDEDEDDDDDDDCDCDCDBDBDBDADADAD9D9D9D8D8D8D7D7D7D6D6D5D5D5D4D4D4D3D3D3D2D2D1D1D1D0D0CFCFCFCECECDCDCDCCCCCBCBCBCACAC9C9C9C8C8C7C7C6C6C6C5C5C4C4C3C3C2C2C2C1C1C0C0BFBFBEBEBDBDBCBCBBBBBABABAB9B9B8B8B7B7B6B6B5B4B4B3B3B2B2B1B1B0B0AFAFAEAEADADACABABAAAAA9A9A8A8A7A6A6A5A5A4A4A3A2A2A1A1A0A09F9E9E9D9D9C9B9B9A999998989796969594949393929191908F8F8E8D8D8C8B8B8A8989888787868585848382828180807F7E7E7D7C7B7B7A79787877767675747373727170706F6E6D6C6C6B6A696968676665656463626161605F5E5D5D5C5B5A5958585756555453535251504F4E4D4D4C4B4A49484746464544434241403F3E3E3D3C3B3A39383736353433323131302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A090706050403020100>0 %_Br[1 0 50 100 %_Bs0 0 13 80 %_Bs0.57 0 50 57 %_Bs1 0 50 48 %_Bs0.58 0 50 40 %_Bs0 0 50 28 %_Bs1 0 76 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Green & Blue)(Green & Blue) 0 2 Bd[<99999A9A9B9B9B9C9C9D9D9D9E9E9F9F9FA0A0A1A1A1A2A2A3A3A3A4A4A5A5A5A6A6A7A7A7A8A8A9A9A9AAAAABABABACACADADADAEAEAFAFAFB0B0B1B1B1B2B2B3B3B3B4B4B5B5B5B6B6B7B7B7B8B8B9B9B9BABABBBBBBBCBCBDBDBDBEBEBFBFBFC0C0C1C1C1C2C2C3C3C3C4C4C5C5C5C6C6C7C7C7C8C8C9C9C9CACACBCBCBCCCCCDCDCDCECECFCFCFD0D0D1D1D1D2D2D3D3D3D4D4D5D5D5D6D6D7D7D7D8D8D9D9D9DADADBDBDBDCDCDDDDDDDEDEDFDFDFE0E0E1E1E1E2E2E3E3E3E4E4E5E5E5E6E6E7E7E7E8E8E9E9E9EAEAEBEBEBECECEDEDEDEEEEEFEFEFF0F0F1F1F1F2F2F3F3F3F4F4F5F5F5F6F6F7F7F7F8F8F9F9F9FAFAFBFBFBFCFCFDFDFDFEFEFFFF><000102020304050506070808090A0B0B0C0D0E0E0F101111121314141516171718191A1A1B1C1D1D1E1F20202122232324252626272829292A2B2C2C2D2E2F2F303132323334353536373838393A3B3B3C3D3E3E3F404141424344444546474748494A4A4B4C4D4D4E4F50505152535354555656575859595A5B5C5C5D5E5F5F606162626364656566676868696A6B6B6C6D6E6E6F707171727374747576777778797A7A7B7C7D7D7E7F80808182828384858586878888898A8B8B8C8D8E8E8F909191929394949596979798999A9A9B9C9D9D9E9FA0A0A1A2A3A3A4A5A6A6A7A8A9A9AAABACACADAEAFAFB0B1B2B2B3B4B5B5B6B7B8B8B9BABBBBBCBDBEBEBF><FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>01 %_Br[1 0.75 0 0 1 50 100 %_Bs0.6 0 1 0 1 50 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Pink, Yellow, Green)(Pink, Yellow, Green) 0 3 Bd[<0000000000000000000000000000000000000001010101010101010101010101010101010101010101010101010202020202020202020202020202020202020202020203030303030303030303030303030303030303030304040404040404040404040404040404040404040505050505050505050505050505050505050506060606060606060606060606060606060606070707070707070707070707070707070707080808080808080808080808080808080809090909090909090909090909090909090A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0D0D0D0D0D><050506060606070708080809090A0A0A0B0B0C0C0D0D0E0E0F0F101011111212131314141515161717181819191A1A1B1C1C1D1D1E1F1F202021222223232425252626272828292A2A2B2C2C2D2D2E2F2F3031313233333435353637373839393A3B3B3C3D3E3E3F4040414242434445454647474849494A4B4C4C4D4E4F4F505151525354545556575758595A5A5B5C5C5D5E5F5F606162636364656666676869696A6B6C6C6D6E6F707071727373747576777778797A7B7B7C7D7E7F7F8081828383848586878788898A8B8B8C8D8E8F8F9091929394949596979898999A9B9C9D9D9E9FA0A1A2A2A3A4A5A6A7A7A8A9AAABACADADAEAFB0B1B2B2><CCCCCBCBCBCACACAC9C9C8C8C7C7C6C6C5C5C4C4C3C2C2C1C1C0C0BFBEBEBDBDBCBBBBBAB9B9B8B7B7B6B6B5B4B4B3B2B1B1B0AFAFAEADADACABAAAAA9A8A8A7A6A5A5A4A3A2A2A1A0A09F9E9D9C9C9B9A999998979696959493929291908F8E8E8D8C8B8A8A8988878686858483828181807F7E7D7C7C7B7A7978777776757473727171706F6E6D6C6B6A6A69686766656463636261605F5E5D5C5B5B5A59585756555453525151504F4E4D4C4B4A49484746464544434241403F3E3D3C3B3A39383837363534333231302F2E2D2C2B2A29282726252423222221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>01 %_Br<737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5B5A59585756555453525150504F4E4D4C4B4A4949484746454443434241403F3E3E3D3C3B3A3A393837363635343333323130302F2E2D2D2C2B2A2A29282827262525242323222121201F1F1E1D1D1C1C1B1A1A19181817171616151414131312121111100F0F0E0E0D0D0C0C0C0B0B0A0A090908080807070606060505050404040303030202020201010101010000000000><00000000000000000000000001010101010101010101010101010101010101010101010102020202020202020202020202020202020202020202020202020303030303030303030303030303030303030303030303030303030303030304040404040404040404040404040404040404040404040404040404040404040404040404050505050505050505050505050505050505050505050505050505050505050505050505050505050505><BFBFBFC0C0C0C0C0C0C0C0C0C1C1C1C1C1C1C1C1C1C2C2C2C2C2C2C2C2C2C2C3C3C3C3C3C3C3C3C3C3C4C4C4C4C4C4C4C4C4C4C5C5C5C5C5C5C5C5C5C5C5C6C6C6C6C6C6C6C6C6C6C6C6C7C7C7C7C7C7C7C7C7C7C7C7C8C8C8C8C8C8C8C8C8C8C8C8C8C9C9C9C9C9C9C9C9C9C9C9C9C9C9C9CACACACACACACACACACACACACACACACACBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC>01 %_Br[0.05 0.7 0 0 1 50 100 %_Bs0 0.02 0.8 0 1 57 36 %_Bs0.45 0 0.75 0 1 37 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Rainbow)(Rainbow) 0 6 Bd[<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>1001 %_Br1<0708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF>001 %_Br1<00000000000000000000000000000000000001010101010101010101010101010101010101010101010101010101010101010101010102020202020202020202020202020202020202020202020202020202020202020202020203030303030303030303030303030303030303030303030303030303030303030303030304040404040404040404040404040404040404040404040404040404040404040404040405050505050505050505050505050505050505050505050505050505050505050505050506060606060606060606060606060606060606060606060606060606060606060606060607070707070707070707070707070707070707070707><FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>01 %_Br<000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF>0101 %_Br0<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>101 %_Br[0 1 0 0 1 50 100 %_Bs1 1 0 0 1 50 80 %_Bs1 0.0279 0 0 1 50 60 %_Bs1 0 1 0 1 50 40 %_Bs0 0 1 0 1 50 20 %_Bs0 1 1 0 1 50 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (screen)(screen) 0 3 Bd[0<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A><CCCCCCCDCDCDCDCDCECECECECECFCFCFCFD0D0D0D0D0D1D1D1D1D1D2D2D2D2D2D3D3D3D3D3D4D4D4D4D5D5D5D5D5D6D6D6D6D6D7D7D7D7D7D8D8D8D8D8D9D9D9D9DADADADADADBDBDBDBDBDCDCDCDCDCDDDDDDDDDDDEDEDEDEDFDFDFDFDFE0E0E0E0E0E1E1E1E1E1E2E2E2E2E2E3E3E3E3E4E4E4E4E4E5E5E5E5E5E6E6E6E6E6E7E7E7E7E7E8E8E8E8E9E9E9E9E9EAEAEAEAEAEBEBEBEBEBECECECECECEDEDEDEDEEEEEEEEEEEFEFEFEFEFF0F0F0F0F0F1F1F1F1F1F2F2F2F2F3F3F3F3F3F4F4F4F4F4F5F5F5F5F5F6F6F6F6F6F7F7F7F7F8F8F8F8F8F9F9F9F9F9FAFAFAFAFAFBFBFBFBFBFCFCFCFCFDFDFDFDFDFEFEFEFEFEFFFFFF>01 %_Br<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100><8080808181828283838484858586868787888889898A8A8B8B8C8C8D8D8E8E8F8F90909191929293939494959596969797989899999A9A9B9B9C9C9D9D9E9E9F9FA0A0A1A1A2A2A3A3A4A4A5A5A6A6A7A7A8A8A9A9AAAAABABACACADADAEAEAFAFB0B0B1B1B2B2B3B3B4B4B5B5B6B6B7B7B8B8B9B9BABABBBBBCBCBDBDBEBEBFBFC0C0C1C1C2C2C3C3C4C4C5C5C6C6C7C7C8C8C9C9CACACBCBCCCCCDCDCECECFCFD0D0D1D1D2D2D3D3D4D4D5D5D6D6D7D7D8D8D9D9DADADBDBDCDCDDDDDEDEDFE0E0E1E1E2E2E3E3E4E4E5E5E6E6E7E7E8E8E9E9EAEAEBEBECECEDEDEEEEEFEFF0F0F1F1F2F2F3F3F4F4F5F5F6F6F7F7F8F8F9F9FAFAFBFBFCFCFDFDFEFEFFFF><0001020203040506060708090A0A0B0C0D0E0E0F1011121213141516161718191A1A1B1C1D1E1E1F2021222223242526262728292A2A2B2C2D2E2E2F3031323233343536363738393A3A3B3C3D3E3E3F4041424243444546464748494A4A4B4C4D4E4E4F5051525253545556565758595A5A5B5C5D5E5E5F6061626263646566666768696A6A6B6C6D6E6E6F7071727273747576767778797A7A7B7C7D7E7E7F8081828283848586868788898A8A8B8C8D8E8E8F9091929293949596969798999A9A9B9C9D9E9E9FA0A1A2A2A3A4A5A6A6A7A8A9AAAAABACADAEAEAFB0B1B2B2B3B4B5B6B6B7B8B9BABABBBCBDBEBEBFC0C1C2C2C3C4C5C6C6C7C8C9CACACBCC>01 %_Br[0 0.04 1 0 1 50 100 %_Bs0 1 0.8 0 1 50 50 %_Bs1 0.5 0 0 (Blue) 0 3 50 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Steel Bar)(Steel Bar) 0 3 Bd[<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>0 %_Br<000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF>0 %_Br[0 0 50 100 %_Bs1 0 50 70 %_Bs0 0 50 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Yellow & Orange Radial)(Yellow & Orange Radial) 1 2 Bd[0<0001010203040506060708090A0B0C0C0D0E0F10111213131415161718191A1B1C1D1D1E1F202122232425262728292A2B2B2C2D2E2F303132333435363738393A3B3C3D3E3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F60606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C><FFFFFFFFFEFEFEFEFEFEFEFDFDFDFDFDFDFCFCFCFCFCFCFBFBFBFBFBFBFAFAFAFAFAFAF9F9F9F9F9F9F8F8F8F8F8F8F7F7F7F7F7F7F6F6F6F6F6F6F5F5F5F5F5F5F4F4F4F4F4F3F3F3F3F3F3F2F2F2F2F2F2F1F1F1F1F1F0F0F0F0F0F0EFEFEFEFEFEFEEEEEEEEEEEDEDEDEDEDEDECECECECECEBEBEBEBEBEBEAEAEAEAEAE9E9E9E9E9E9E8E8E8E8E8E8E7E7E7E7E7E6E6E6E6E6E5>01 %_Br[0 0 1 0 1 52 19 %_Bs0 0.55 0.9 0 1 50 100 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Yellow & Purple Radial)(Yellow & Purple Radial) 1 2 Bd[<000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF><1415161718191A1B1C1D1E1F1F202122232425262728292A2A2B2C2D2E2F30313233343536363738393A3B3C3D3E3F40414142434445464748494A4B4C4D4D4E4F50515253545556575858595A5B5C5D5E5F60616263646465666768696A6B6C6D6E6F6F707172737475767778797A7B7B7C7D7E7F80818283848586868788898A8B8C8D8E8F90919292939495969798999A9B9C9D9D9E9FA0A1A2A3A4A5A6A7A8A9A9AAABACADAEAFB0B1B2B3B4B4B5B6B7B8B9BABBBCBDBEBFC0C0C1C2C3C4C5C6C7C8C9CACBCBCCCDCECFD0D1D2D3D4D5D6D7D7D8D9DADBDCDDDEDFE0E1E2E2E3E4E5E6E7E8E9EAEBECEDEEEEEFF0F1F2F3F4F5F6F7F8F9F9FAFBFCFDFEFF><ABAAAAA9A8A7A7A6A5A5A4A3A3A2A1A1A09F9F9E9D9D9C9B9B9A9999989797969595949393929191908F8F8E8D8D8C8B8B8A8989888787868585848383828181807F7F7E7D7D7C7B7B7A7979787777767575747373727171706F6F6E6D6D6C6B6B6A6969686767666565646362626160605F5E5E5D5C5C5B5A5A5958585756565554545352525150504F4E4E4D4C4C4B4A4A4948484746464544444342424140403F3E3E3D3C3C3B3A3A3938383736363534343332323130302F2E2E2D2C2C2B2A2A29282827262625242423222121201F1F1E1D1D1C1B1B1A1919181717161515141313121111100F0F0E0D0D0C0B0B0A090908070706050504030302010100>01 %_Br[0 0.08 0.67 0 1 50 14 %_Bs1 1 0 0 1 50 100 %_BsBD%AI5_EndGradient%AI5_End_NonPrinting--%AI5_BeginPalette0 9 PbPnPc1 gPc0 gPc0 0 0 0 kPc0.75 gPc0.5 gPc0.25 gPc0 gPcBb2 (Black & White) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.27 0 0.64 0 kPc1 0.27 0 0.16 kPc1 0.1 0 0 kPc1 0 0 0 kPc0.25 0.25 0 0 kPc0.27 0 0.64 0 kPcPc0.46 0 1 0 kPcBb2 (Pink, Yellow, Green) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0 0.25 0 0 kPc0 0.5 0 0 kPc0 0.75 0 0 kPc0 1 0 0 kPc0 0.25 0.25 0 kPc0 0.5 0.5 0 kPc0 0.75 0.75 0 kPc0 1 1 0 kPcBb0 0 0 0 Bh2 (Yellow & Purple Radial) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0 0 0.25 0 kPc0 0 0.5 0 kPc0 0 0.75 0 kPc0 0 1 0 kPc0.25 0 0.25 0 kPc0.5 0 0.5 0 kPc0.75 0 0.75 0 kPc1 0 1 0 kPcBb2 (Rainbow) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.25 0.125 0 0 kPc0.5 0.25 0 0 kPc0.75 0.375 0 0 kPc1 0.5 0 0 kPc0.125 0.25 0 0 kPc0.25 0.5 0 0 kPc0.21 0 0.59 0 kPc0.46 0 1 0 kPcBb2 (Steel Bar) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0 0.25 0.125 0 kPc0 0.5 0.25 0 kPc0 0.75 0.375 0 kPc0 1 0.5 0 kPc0 0.125 0.25 0 kPc0 0.25 0.5 0 kPc0 0.375 0.75 0 kPc0 0.5 1 0 kPcBb2 (screen) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.125 0 0.25 0 kPc0.25 0 0.5 0 kPc0.375 0 0.75 0 kPc0.5 0 1 0 kPc0.25 0 0.125 0 kPc0.5 0 0.25 0 kPc0.75 0 0.375 0 kPc1 0 0.5 0 kPcBb2 (Green & Blue) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.25 0.125 0.125 0 kPc0.5 0.25 0.25 0 kPc0.75 0.375 0.375 0 kPc1 0.5 0.5 0 kPc0.25 0.25 0.125 0 kPc0.5 0.5 0.25 0 kPc0.75 0.75 0.375 0 kPc1 1 0.5 0 kPcBb0 0 0 0 Bh2 (Yellow & Orange Radial) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.125 0.25 0.125 0 kPc0.25 0.5 0.25 0 kPc0.375 0.75 0.375 0 kPc0.5 1 0.5 0 kPc0.125 0.25 0.25 0 kPc0.25 0.5 0.5 0 kPc0.375 0.75 0.75 0 kPc0.5 1 1 0 kPc0 0 0 0 kPc0.125 0.125 0.25 0 kPc0.25 0.25 0.5 0 kPc0.375 0.375 0.75 0 kPc0.5 0.5 1 0 kPc0.25 0.125 0.25 0 kPc0.5 0.25 0.5 0 kPc0.75 0.375 0.75 0 kPc1 0.5 1 0 kPcPB%AI5_EndPalette%%EndSetup%AI5_BeginLayer1 1 1 1 0 0 0 79 128 255 Lb(Layer 1) Ln0 A*u0 O0.27 0 0.64 0 k800 Ar0 J 0 j 1 w 4 M []0 d%AI3_Note:0 D0 XR396.0473 553.4443 m394.8232 553.4443 393.9351 554.3804 393.9351 555.6525 c393.9351 556.9726 394.8232 557.8847 396.0953 557.8847 c397.3434 557.8847 398.2075 556.9966 398.2315 555.6525 c398.2315 554.3804 397.3674 553.4443 396.0713 553.4443 C396.0473 553.4443 lf*U*u380.5015 553.7083 m380.5015 555.9165 L382.4937 557.7167 L385.926 560.7889 387.5821 562.5411 387.6061 564.3652 c387.6061 565.6374 386.862 566.6454 385.0619 566.6454 c383.7178 566.6454 382.5417 565.9734 381.7256 565.3733 c380.6935 567.9656 L381.8456 568.8536 383.6938 569.5737 385.7819 569.5737 c389.3343 569.5737 391.2544 567.5095 391.2544 564.6773 c391.2544 562.061 389.3823 559.9729 387.1021 557.9567 c385.6619 556.7566 L385.6619 556.7086 L391.5664 556.7086 L391.5664 553.7083 L380.5015 553.7083 lf*U*u407.2312 553.5309 m402.7357 553.5309 400.07 556.942 400.07 561.2794 c400.07 565.8426 403.0068 569.2537 407.4797 569.2537 c412.1558 569.2537 414.7085 565.7523 414.7085 561.5505 c414.7085 556.5354 411.704 553.5309 407.2537 553.5309 C407.2312 553.5309 lf1 D407.3893 556.2643 m409.7161 556.2643 411.0489 558.4556 411.0489 561.4375 c411.0489 564.1709 409.7612 566.5203 407.3893 566.5203 c405.0173 566.5203 403.6845 564.2161 403.6845 561.3697 c403.6845 558.5008 405.0625 556.2643 407.3667 556.2643 C407.3893 556.2643 lf*Uu0.46 0 1 0 k0 R0.46 0 1 0 K1.671 w0 D493.7796 511.986 m491.7142 509.4223 486.1517 509.3549 v481.8676 509.303 479.8611 509.145 478.9635 508.5326 c477.5953 507.5993 477.4611 505.9678 477.6268 504.4667 c477.6929 503.868 477.8009 501.5924 483.3081 501.2919 c491.0419 500.8698 493.8909 503.6869 y481.7164 499.7945 478.9635 503.7425 v478.1847 504.8596 478.091 506.7543 479.7433 507.8643 c481.8618 509.2875 492.1085 507.363 493.7796 511.986 c(b) *494.6707 516.8319 m493.1119 523.4083 476.9584 529.8655 v470.4991 532.4475 472.6138 536.3404 474.619 536.8836 c476.5811 537.415 483.4752 538.8888 490.9945 532.2049 c481.3316 538.3165 474.9949 536.0481 v472.6286 535.2009 473.8963 532.8215 474.5354 532.2049 c476.9167 529.9073 493.501 525.3539 494.6707 516.8319 c(b) *474.4519 539.4457 m471.7283 543.1826 474.619 543.6231 v478.833 544.2653 483.1403 543.4027 487.3184 542.0635 c491.6629 540.6711 495.339 538.5546 y483.8652 542.6762 479.5205 542.9548 v474.9613 543.247 474.5077 542.9548 474.1734 542.2864 c473.7384 541.4163 474.4519 539.4457 y(b) *496.589 544.5138 m495.1006 545.622 491.6403 546.3035 488.9246 546.425 c485.3238 546.5859 485.3683 544.6529 y485.309 544.9105 485.1307 546.0095 485.7324 546.3122 c486.9508 546.9252 489.1213 547.1614 492.828 546.4278 c496.5343 545.6941 496.589 544.5138 y(b) *U1 w185.5 4716 m185.5 -3924 L(N) *-4014 613.875 m4626 613.875 L(N) *-4014 548 m4626 548 L(N) *0 O316.5821 607.027 mBb2 ( 3) 153.6667 657.0833 0 151 1.1617 0 0 1.1617 -686.0627 -637.3755 Bg1 0 0 -1 -4014 4716 Bc0.32 0 0 -1 -4014 4716 Bm0.13 0 0 -1 -4013.68 4716 Bm0.14 0 0 -1 -4013.55 4716 Bm0.11 0 0 -1 -4013.41 4716 Bm0.3 0 0 -1 -4013.3 4716 Bm1 0 0 -1 -4014 4716 BcF0 BB*u0.27 0 0.64 0 k161.3029 613.5375 m154.6726 637.9785 L151.9425 612.2375 L142.5822 613.9925 L149.9925 652.539 L158.7028 652.539 L165.6581 626.1479 L172.6133 652.539 L181.3237 652.539 L188.7339 613.9925 L179.3736 612.2375 L176.6435 637.9785 L170.0132 613.5375 L161.3029 613.5375 lf*U*u219.0881 626.408 m219.0881 622.1179 220.6481 619.1278 224.0283 616.5276 c216.098 612.4974 L213.8229 614.7725 213.3029 615.5525 v210.5078 612.2375 205.4376 612.2375 v199.3923 612.2375 193.6721 616.7227 193.6721 622.6379 c193.6721 629.0731 198.9373 632.7133 207.3876 632.7133 c209.6627 632.7133 209.9877 632.7133 y209.9877 634.7933 208.6877 636.5484 206.0876 636.5484 c203.5525 636.5484 202.0574 635.4434 y197.3123 641.6186 L200.8874 644.7387 206.0876 644.7387 v214.2129 644.7387 219.0881 639.6035 219.0881 632.7133 C219.0881 626.408 lf1 D209.9877 626.6679 m207.6477 626.6679 207.3876 626.6679 v203.7475 626.6679 202.8375 624.6529 202.9025 622.6379 c202.9675 620.8177 204.9176 619.7778 206.2826 619.7778 c208.7527 619.7778 210.5078 621.5328 y210.1828 623.3529 209.9877 625.303 209.9877 626.6679 cf*U*u0 D242.9396 626.018 m242.9396 621.7279 244.4996 618.7377 247.8797 616.1376 c239.9494 612.1074 L235.6593 616.0726 233.8392 620.1027 233.8392 626.018 c233.8392 634.9884 L227.989 634.9884 L227.989 643.4387 L233.8392 643.4387 L233.8392 652.539 L242.9396 652.539 L242.9396 643.4387 L249.1148 643.4387 L249.1148 634.9884 L242.9396 634.9884 L242.9396 626.018 lf*U*u256.2557 658.3892 m265.3561 658.3892 L265.3561 640.5135 L268.2812 644.8686 274.0664 644.8686 v277.9016 644.8686 282.9068 642.1385 282.9068 635.9634 c282.9068 613.5375 L273.8064 613.5375 L273.8064 631.0881 L273.8064 633.2983 273.9364 636.2884 271.5313 636.2884 c266.0061 636.2884 265.3561 630.5682 y265.3561 613.5375 L256.2557 613.5375 L256.2557 658.3892 lf*U*u298.4913 625.888 m295.5662 626.9931 290.041 628.813 290.041 635.3134 c290.041 640.8386 295.8912 644.7387 301.7414 644.7387 c306.6166 644.7387 309.5417 643.1137 312.2718 640.5135 c307.5917 634.6632 L306.2916 636.1584 304.0165 636.9384 302.3915 636.9384 c300.1814 636.9384 298.4913 636.4183 298.4913 634.7933 c298.4913 633.6233 300.1164 633.1683 301.4164 632.7133 c304.0165 631.7382 L307.7867 630.3081 312.4668 628.813 312.4668 622.3128 c312.4668 616.4627 306.6816 612.2375 300.7664 612.2375 c295.8912 612.2375 291.9911 613.5375 289.066 616.7877 c293.6161 623.2879 L294.9162 621.6629 297.7763 620.0377 300.1164 620.0377 c302.3915 620.0377 304.0165 620.6878 304.0165 622.5079 c304.0165 623.9378 302.3915 624.393 301.0914 624.913 C298.4913 625.888 lf*U*u0.21 0 0.59 0 k341.0607 630.1132 m322.21 630.1132 L322.21 639.8634 L341.0607 639.8634 L341.0607 630.1132 lf*U*u0.27 0 0.64 0 k165.8927 552.0375 m157.7325 582.1182 L154.3724 550.4375 L142.8522 552.5975 L151.9724 600.0386 L162.6926 600.0386 L171.2528 567.5579 L179.813 600.0386 L190.5333 600.0386 L199.6535 552.5975 L188.1332 550.4375 L184.7731 582.1182 L176.613 552.0375 L165.8927 552.0375 lf*U*u236.2133 567.8778 m236.2133 562.5978 238.1333 558.9177 242.2934 555.7176 c232.5332 550.7575 L229.7331 553.5576 229.0931 554.5176 v225.653 550.4375 219.4129 550.4375 v211.9727 550.4375 204.9325 555.9575 204.9325 563.2378 c204.9325 571.158 211.4127 575.6381 221.8129 575.6381 c224.613 575.6381 225.013 575.6381 y225.013 578.1981 223.413 580.3582 220.2129 580.3582 c217.0928 580.3582 215.2528 578.9981 y209.4126 586.5982 L213.8127 590.4384 220.2129 590.4384 v230.2131 590.4384 236.2133 584.1183 236.2133 575.6381 C236.2133 567.8778 lf1 D225.013 568.1979 m222.1329 568.1979 221.8129 568.1979 v217.3328 568.1979 216.2128 565.7178 216.2928 563.2378 c216.3728 560.9978 218.7729 559.7176 220.4529 559.7176 c223.493 559.7176 225.653 561.8778 y225.253 564.1177 225.013 566.5178 225.013 568.1979 cf*U*u0 D257.1694 567.2378 m253.5693 568.5979 246.7691 570.8379 246.7691 578.8381 c246.7691 585.6383 253.9693 590.4384 261.1695 590.4384 c267.1696 590.4384 270.7697 588.4384 274.1298 585.2382 c268.3696 578.0381 L266.7696 579.8782 263.9695 580.8381 261.9695 580.8381 c259.2494 580.8381 257.1694 580.1981 257.1694 578.1981 c257.1694 576.7581 259.1694 576.1981 260.7695 575.6381 c263.9695 574.438 L268.6096 572.678 274.3698 570.8379 274.3698 562.8377 c274.3698 555.6376 267.2496 550.4375 259.9694 550.4375 c253.9693 550.4375 249.1692 552.0375 245.5691 556.0375 c251.1692 564.0377 L252.7693 562.0377 256.2893 560.0377 259.1694 560.0377 c261.9695 560.0377 263.9695 560.8377 263.9695 563.0778 c263.9695 564.8377 261.9695 565.3979 260.3694 566.0379 C257.1694 567.2378 lf*U*u298.3621 567.3979 m298.3621 562.1177 300.2821 558.4376 304.4422 555.2376 c294.682 550.2774 L289.4019 555.1576 287.1618 560.1177 287.1618 567.3979 c287.1618 578.4382 L279.9617 578.4382 L279.9617 588.8384 L287.1618 588.8384 L287.1618 600.0386 L298.3621 600.0386 L298.3621 588.8384 L305.9622 588.8384 L305.9622 578.4382 L298.3621 578.4382 L298.3621 567.3979 lf*U*u328.9922 560.4376 m335.2324 560.4376 337.3124 563.7178 y344.0326 557.6376 L338.8325 550.4375 328.9922 550.4375 v318.832 550.4375 311.7118 560.2776 311.7118 570.438 c311.7118 580.5982 318.672 590.4384 328.9922 590.4384 c336.9924 590.4384 342.5926 585.9582 344.9126 578.5982 c340.5125 569.878 333.3923 565.3979 322.6721 565.3979 c322.6721 564.5178 324.1921 560.4376 328.9922 560.4376 cf1 D322.4321 572.8379 m328.0322 572.8379 331.0723 574.1981 334.4324 577.158 c333.3923 580.1981 328.9922 580.1981 v324.3521 580.1981 322.4321 574.2781 322.4321 572.8379 cf*U*u0 D366.7344 573.3979 m366.7344 552.0375 L355.5342 552.0375 L355.5342 572.998 L355.5342 578.2781 353.6141 581.9582 349.454 585.1582 c359.2143 590.1184 L361.0543 588.6784 363.2944 585.3983 y369.4545 590.4384 374.7346 590.4384 v377.5347 579.6381 l372.3346 579.6381 366.7344 573.3979 yf*U*u1 0.27 0 0.16 k156.6362 616.2042 m150.0059 640.6452 L147.2758 614.9042 L137.9155 616.6593 L145.3258 655.2057 L154.0361 655.2057 L160.9914 628.8146 L167.9466 655.2057 L176.6569 655.2057 L184.0672 616.6593 L174.7069 614.9042 L171.9768 640.6452 L165.3465 616.2042 L156.6362 616.2042 lf*U*u214.4214 629.0747 m214.4214 624.7846 215.9814 621.7945 219.3616 619.1943 c211.4313 615.1641 L209.1562 617.4393 208.6362 618.2192 v205.8411 614.9042 200.7709 614.9042 v194.7256 614.9042 189.0054 619.3894 189.0054 625.3045 c189.0054 631.7398 194.2706 635.38 202.7209 635.38 c204.996 635.38 205.321 635.38 y205.321 637.46 204.021 639.2151 201.4209 639.2151 c198.8858 639.2151 197.3907 638.1101 y192.6456 644.2853 L196.2207 647.4053 201.4209 647.4053 v209.5462 647.4053 214.4214 642.2702 214.4214 635.38 C214.4214 629.0747 lf1 D205.321 629.3347 m202.981 629.3347 202.7209 629.3347 v199.0808 629.3347 198.1708 627.3197 198.2358 625.3045 c198.3008 623.4844 200.2509 622.4445 201.6159 622.4445 c204.086 622.4445 205.8411 624.1996 y205.516 626.0196 205.321 627.9696 205.321 629.3347 cf*U*u0 D238.2729 628.6847 m238.2729 624.3946 239.8329 621.4044 243.213 618.8043 c235.2827 614.7742 L230.9926 618.7393 229.1725 622.7695 229.1725 628.6847 c229.1725 637.6551 L223.3223 637.6551 L223.3223 646.1054 L229.1725 646.1054 L229.1725 655.2057 L238.2729 655.2057 L238.2729 646.1054 L244.4481 646.1054 L244.4481 637.6551 L238.2729 637.6551 L238.2729 628.6847 lf*U*u251.589 661.0559 m260.6894 661.0559 L260.6894 643.1802 L263.6145 647.5354 269.3997 647.5354 v273.2349 647.5354 278.24 644.8052 278.24 638.63 c278.24 616.2042 L269.1397 616.2042 L269.1397 633.7548 L269.1397 635.9649 269.2697 638.9551 266.8646 638.9551 c261.3394 638.9551 260.6894 633.2349 y260.6894 616.2042 L251.589 616.2042 L251.589 661.0559 lf*U*u293.8246 628.5547 m290.8995 629.6598 285.3743 631.4797 285.3743 637.9801 c285.3743 643.5052 291.2245 647.4053 297.0747 647.4053 c301.9499 647.4053 304.875 645.7803 307.6051 643.1802 c302.925 637.33 L301.6249 638.8251 299.3498 639.6051 297.7248 639.6051 c295.5147 639.6051 293.8246 639.085 293.8246 637.46 c293.8246 636.29 295.4497 635.835 296.7497 635.38 c299.3498 634.4049 L303.12 632.9748 307.8001 631.4797 307.8001 624.9795 c307.8001 619.1294 302.0149 614.9042 296.0997 614.9042 c291.2245 614.9042 287.3244 616.2042 284.3993 619.4544 c288.9494 625.9546 L290.2495 624.3296 293.1096 622.7044 295.4497 622.7044 c297.7248 622.7044 299.3498 623.3545 299.3498 625.1746 c299.3498 626.6045 297.7248 627.0597 296.4247 627.5796 C293.8246 628.5547 lf*U*u336.394 632.7799 m317.5433 632.7799 L317.5433 642.5301 L336.394 642.5301 L336.394 632.7799 lf*U*u161.226 554.7042 m153.0658 584.7848 L149.7057 553.1042 L138.1855 555.2642 L147.3057 602.7053 L158.0259 602.7053 L166.5861 570.2246 L175.1463 602.7053 L185.8666 602.7053 L194.9868 555.2642 L183.4665 553.1042 L180.1064 584.7848 L171.9463 554.7042 L161.226 554.7042 lf*U*u231.5466 570.5446 m231.5466 565.2644 233.4666 561.5843 237.6267 558.3843 c227.8665 553.4242 L225.0664 556.2243 224.4264 557.1842 v220.9863 553.1042 214.7462 553.1042 v207.306 553.1042 200.2658 558.6242 200.2658 565.9044 c200.2658 573.8247 206.746 578.3048 217.1462 578.3048 c219.9463 578.3048 220.3463 578.3048 y220.3463 580.8648 218.7463 583.0249 215.5462 583.0249 c212.4261 583.0249 210.5861 581.6649 y204.7459 589.2649 L209.146 593.1051 215.5462 593.1051 v225.5464 593.1051 231.5466 586.785 231.5466 578.3048 C231.5466 570.5446 lf1 D220.3463 570.8646 m217.4662 570.8646 217.1462 570.8646 v212.6661 570.8646 211.5461 568.3845 211.6261 565.9044 c211.7061 563.6645 214.1062 562.3843 215.7862 562.3843 c218.8263 562.3843 220.9863 564.5445 y220.5863 566.7845 220.3463 569.1846 220.3463 570.8646 cf*U*u0 D252.5027 569.9046 m248.9026 571.2646 242.1024 573.5046 242.1024 581.5048 c242.1024 588.305 249.3026 593.1051 256.5028 593.1051 c262.5029 593.1051 266.103 591.1051 269.4631 587.9049 c263.7029 580.7048 L262.1029 582.5449 259.3028 583.5048 257.3028 583.5048 c254.5827 583.5048 252.5027 582.8648 252.5027 580.8648 c252.5027 579.4248 254.5027 578.8648 256.1027 578.3048 c259.3028 577.1047 L263.9429 575.3446 269.7031 573.5046 269.7031 565.5045 c269.7031 558.3043 262.5829 553.1042 255.3027 553.1042 c249.3026 553.1042 244.5025 554.7042 240.9024 558.7042 c246.5025 566.7044 L248.1026 564.7044 251.6226 562.7044 254.5027 562.7044 c257.3028 562.7044 259.3028 563.5045 259.3028 565.7445 c259.3028 567.5045 257.3028 568.0646 255.7027 568.7046 C252.5027 569.9046 lf*U*u293.6954 570.0646 m293.6954 564.7845 295.6154 561.1044 299.7755 557.9042 c290.0153 552.9441 L284.7352 557.8242 282.4951 562.7844 282.4951 570.0646 c282.4951 581.1049 L275.2949 581.1049 L275.2949 591.505 L282.4951 591.505 L282.4951 602.7053 L293.6954 602.7053 L293.6954 591.505 L301.2955 591.505 L301.2955 581.1049 L293.6954 581.1049 L293.6954 570.0646 lf*U*u324.3255 563.1044 m330.5657 563.1044 332.6457 566.3845 y339.3659 560.3043 L334.1658 553.1042 324.3255 553.1042 v314.1653 553.1042 307.0451 562.9443 307.0451 573.1047 c307.0451 583.2649 314.0053 593.1051 324.3255 593.1051 c332.3257 593.1051 337.9259 588.625 340.2459 581.2649 c335.8458 572.5447 328.7256 568.0646 318.0054 568.0646 c318.0054 567.1845 319.5254 563.1044 324.3255 563.1044 cf1 D317.7654 575.5046 m323.3655 575.5046 326.4056 576.8648 329.7657 579.8247 c328.7256 582.8648 324.3255 582.8648 v319.6854 582.8648 317.7654 576.9448 317.7654 575.5046 cf*U*u0 D362.0677 576.0646 m362.0677 554.7042 L350.8675 554.7042 L350.8675 575.6647 L350.8675 580.9449 348.9474 584.6249 344.7873 587.8249 c354.5476 592.785 L356.3876 591.3451 358.6277 588.065 y364.7878 593.1051 370.0679 593.1051 v372.868 582.3049 l367.6679 582.3049 362.0677 576.0646 yf*Uu0 R0.27 0 0.64 0 K2.5412 w298.3297 599.6468 m317.6872 614.824 324.1089 599.805 336.1457 605.2324 c341.6632 607.7203 335.8106 617.1504 342.0411 622.9499 c348.4903 628.953 355.7107 620.8292 yS1 Ap0 O0 0 0 0 k2.5354 w377.5564 605.0772 m382.5937 612.455 377.5592 618.2315 370.8644 622.8023 c364.1697 627.3731 360.1161 629.3404 354.3622 620.9131 c348.1307 611.7861 353.411 610.1267 360.1057 605.5559 c366.8004 600.9851 372.5193 597.6995 377.5564 605.0772 cbUu0 Ap0.46 0 1 0 k0.46 0 1 0 K1.8578 w399.4605 605.9929 m397.2616 603.3845 391.4228 603.385 v386.9261 603.3854 384.8185 603.2481 383.8689 602.6302 c382.4216 601.6883 382.2607 600.0135 382.4161 598.469 c382.4782 597.8529 382.5635 595.5135 388.3396 595.1354 c396.4509 594.6047 399.4755 597.4638 y386.6508 593.6168 383.8101 597.7082 v383.0066 598.8657 382.9314 600.8139 384.6791 601.9336 c386.9199 603.3695 397.65 601.2635 399.4605 605.9929 cb400.4249 610.9251 m398.3436 617.5657 380.9846 623.1164 v374.0435 625.3359 376.3947 629.9486 378.4577 630.6385 c380.4765 631.3135 389.0557 631.033 398.0703 623.796 c383.4996 631.8964 378.9085 629.8067 v376.5169 628.7181 377.3802 626.141 378.0916 625.5512 c380.7422 623.3529 398.6182 619.5866 400.4249 610.9251 cb1.6007 w379.112 632.9203 m378.5215 633.458 378.2626 634.1558 v377.8867 635.1688 378.5037 636.8861 380.064 637.0104 c383.9058 637.3166 387.3606 636.7649 391.0454 635.3233 c394.8771 633.8242 400.2028 629.7738 y389.7137 635.611 384.8694 636.1455 v380.7638 636.5986 380.0259 636.3526 379.5781 635.8574 c378.3141 634.4598 379.112 632.9203 yb1.6492 w401.1896 635.8881 m402.2594 634.9161 404.1195 633.0915 y403.0368 634.4116 398.2024 637.516 395.782 638.2467 c392.5723 639.2158 392.16 637.499 y392.1669 637.74 392.2633 638.7512 392.8769 638.8802 c393.5241 639.0164 395.5696 639.3601 398.9061 637.3578 c399.821 636.8086 400.7206 636.3139 401.1896 635.8881 cbU*u1.3016 w362.1959 610.4546 m360.5524 610.4618 L360.5756 615.7799 L358.8638 615.7875 L358.8705 617.3168 L363.9378 617.2947 L363.9311 615.7653 L362.2191 615.7729 L362.1959 610.4546 lf*U*u367.8691 610.4299 m366.7236 614.7259 L366.2246 610.2087 L364.5825 610.524 L365.9131 617.2861 L367.4424 617.2794 L368.6434 612.6405 L369.8847 617.2687 L371.414 617.262 L372.6855 610.4886 L371.0407 610.1876 L370.5811 614.7091 L369.3983 610.4232 L367.8691 610.4299 lf*U*u1 0.27 0 0.16 k1 w395.1723 554.3193 m393.9482 554.3193 393.0601 555.2554 393.0601 556.5275 c393.0601 557.8476 393.9482 558.7597 395.2203 558.7597 c396.4684 558.7597 397.3325 557.8716 397.3565 556.5275 c397.3565 555.2554 396.4924 554.3193 395.1963 554.3193 C395.1723 554.3193 lf*U*u379.6265 554.5833 m379.6265 556.7915 L381.6187 558.5917 L385.051 561.6639 386.7071 563.4161 386.7311 565.2402 c386.7311 566.5124 385.987 567.5204 384.1869 567.5204 c382.8428 567.5204 381.6667 566.8484 380.8506 566.2483 c379.8185 568.8406 L380.9706 569.7286 382.8188 570.4487 384.9069 570.4487 c388.4593 570.4487 390.3794 568.3845 390.3794 565.5523 c390.3794 562.936 388.5073 560.8479 386.2271 558.8317 c384.7869 557.6316 L384.7869 557.5836 L390.6914 557.5836 L390.6914 554.5833 L379.6265 554.5833 lf*U-4014 554.625 m4626 554.625 L(N) **u0 O1 0.27 0 0.16 k406.3562 554.4059 m401.8607 554.4059 399.195 557.817 399.195 562.1544 c399.195 566.7176 402.1318 570.1287 406.6047 570.1287 c411.2808 570.1287 413.8335 566.6273 413.8335 562.4255 c413.8335 557.4104 410.829 554.4059 406.3787 554.4059 C406.3562 554.4059 lf1 D406.5143 557.1393 m408.8411 557.1393 410.1739 559.3306 410.1739 562.3125 c410.1739 565.0459 408.8862 567.3953 406.5143 567.3953 c404.1423 567.3953 402.8095 565.0911 402.8095 562.2447 c402.8095 559.3758 404.1875 557.1393 406.4917 557.1393 C406.5143 557.1393 lf*ULB%AI5_EndLayer--%%PageTrailergsave annotatepage grestore showpage%%TrailerAdobe_Illustrator_AI5 /terminate get execAdobe_ColorImage_AI6 /terminate get execAdobe_blend_AI5 /terminate get execAdobe_screens_AI5 /terminate get execAdobe_level2_AI5 /terminate get exec%%EOF