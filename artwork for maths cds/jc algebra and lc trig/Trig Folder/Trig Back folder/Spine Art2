%!PS-Adobe-3.0 EPSF-3.0%%Creator: Adobe Illustrator(r) 6.0.1%%For: (Lorcan) (  )%%Title: (Spine Art2)%%CreationDate: (24/11/01) (9:51 pm)%%BoundingBox: 158 413 463 429%%HiResBoundingBox: 158.0305 413.2315 462.2065 428.2199%%DocumentProcessColors: Cyan Magenta Yellow Black%%DocumentFonts: Myriad-BoldItalic%%DocumentSuppliedResources: procset Adobe_level2_AI5 1.0 0%%+ procset Adobe_screens_AI5 1.0 0%%+ procset Adobe_typography_AI5 1.0 0%%+ procset Adobe_blend_AI5 1.0 0%%+ procset Adobe_Illustrator_AI6_vars Adobe_Illustrator_AI6%%+ procset Adobe_Illustrator_AI5 1.0 0%AI5_FileFormat 2.1%AI3_ColorUsage: Color%%AI6_ColorSeparationSet: 1 1 (AI6 Default Color Separation Set)%%+ Options: 1 16 0 1 0 1 1 1 0 1 1 1 1 18 0 0 0 0 0 0 0 0 -1 -1%%+ PPD: 1 21 0 0 60 45 2 2 1 0 0 1 0 0 0 0 0 0 0 0 0 0 ()%AI3_TemplateBox: 306 396 306 396%AI3_TileBox: 151 -293 703 437%AI3_DocumentPreview: Macintosh_ColorPic%AI5_ArtSize: 368.5039 144%AI5_RulerUnits: 1%AI5_ArtFlags: 0 0 0 1 0 0 0 1 0%AI5_TargetResolution: 800%AI5_NumLayers: 1%AI5_OpenToView: 78 564 2 948 724 58 1 1 2 40%AI5_OpenViewLayers: 7%%EndComments%%BeginProlog% ------------------------------------------------------%%BeginResource: procset Adobe_level2_AI5 1.2 0%%Title: (Adobe Illustrator (R) Version 5.0 Level 2 Emulation)%%Version: 1.2 0%%CreationDate: (04/10/93) ()%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)% ------------------------------------------------------userdict /Adobe_level2_AI5 23 dict dup begin	put% use packed arrays immediately	% packedarray emulation	/packedarray where not	{		userdict begin		/packedarray		{			array astore readonly		} bind def		/setpacking /pop load def		/currentpacking false def		end		0	} if	pop% activate packing now	userdict /defaultpacking currentpacking put true setpacking% initialize, terminate	% note : no binding loop needed here by design	/initialize	{		Adobe_level2_AI5 begin	} bind def	/terminate	{		currentdict Adobe_level2_AI5 eq		{			end		} if	} bind def% mark for later stack clean-up	mark% custom color business	/setcustomcolor where not	{		/findcmykcustomcolor		{			5 packedarray		} bind def		/setcustomcolor		{			exch aload pop pop			4			{				4 index mul 4 1 roll			} repeat			5 -1 roll pop			setcmykcolor		}	% don't bind 'setcmykcolor in this procedure		def	} if%	new version checks for non-numeric version strings (5.0.1 fix bh 10/25/93)%	/gt38? {version cvx exec} stopped {pop true} {38 gt} ifelse def	%	newer version handles errors on clones with cvx or exec which would leave junk on the stack%	(bh 12/2/93)	/gt38? mark {version cvr cvx exec} stopped {cleartomark true} {38 gt exch pop} ifelse def	userdict /deviceDPI 72 0 matrix defaultmatrix dtransform dup mul exch dup mul add sqrt put% test for Level 2 availability	userdict /level2?	systemdict /languagelevel known dup	{		pop systemdict /languagelevel get 2 ge	} if	put/level2ScreenFreq		%	halftoneDict level2ScreenFreq screenFreq{	begin		60	% 60 lpi is default		HalftoneType 1 eq		{			pop Frequency		} if		HalftoneType 2 eq		{			pop GrayFrequency		} if		HalftoneType 5 eq		{			pop Default level2ScreenFreq		} if	end} bind defuserdict /currentScreenFreq  	level2? {currenthalftone level2ScreenFreq} {currentscreen pop pop} ifelse putlevel2? not	{		% LEVEL 1+ EMULATIONS (typesetter/color printer extensions)		% cmyk => gray conversion emulation		% note this revision approved by Ed Taft		% for correcting the out of gamut problem		% in our current emulations		% don't bind these guys so 'setgray/currentgray can be overloaded		/setcmykcolor where not		{			% see red book II, pp. 305			/setcmykcolor			{				exch .11 mul add exch .59 mul add exch .3 mul add				1 exch sub setgray			} def		} if		/currentcmykcolor where not		{			/currentcmykcolor			{				0 0 0 1 currentgray sub			} def		} if		% LEVEL 2 EMULATIONS		% setoverprint emulation		/setoverprint where not		{			/setoverprint /pop load def		} if		% selectfont emulation		/selectfont where not		{			/selectfont			{				exch findfont exch				dup type /arraytype eq				{					makefont				}				{					scalefont				} ifelse				setfont			} bind def		} if		% cshow emulation		/cshow where not		{			% {proc} (string)			/cshow			{				[				0 0 5 -1 roll aload pop				] cvx bind forall			} bind def		} if	} if% clean up	cleartomark	/anyColor?	{		add add add 0 ne	} bind def	/testColor	{		gsave		setcmykcolor currentcmykcolor		grestore	} bind def	/testCMYKColorThrough	{		testColor anyColor?	} bind def	userdict /composite?	level2?	{		gsave 1 1 1 1 setcmykcolor currentcmykcolor grestore		add add add 4 eq	}	{		1 0 0 0 testCMYKColorThrough		0 1 0 0 testCMYKColorThrough		0 0 1 0 testCMYKColorThrough		0 0 0 1 testCMYKColorThrough		and and and	} ifelse	put% *** other separation state tests if we're not on a composite page		composite? not	{		userdict begin		gsave		/cyan? 1 0 0 0 testCMYKColorThrough def		/magenta? 0 1 0 0 testCMYKColorThrough def		/yellow? 0 0 1 0 testCMYKColorThrough def		/black? 0 0 0 1 testCMYKColorThrough def		grestore		/isCMYKSep? cyan? magenta? yellow? black? or or or def		/customColor? isCMYKSep? not def		end	} if	end defaultpacking setpacking%%EndResource% ------------------------------------------------------%%BeginResource: procset Adobe_screens_AI5 1.2 0%%Title: (Adobe Illustrator (R) Version 5.0 Custom Halftone Screens ProcSet)%%Version: 1.2 0%%CreationDate: (03/24/93) ()%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)% ------------------------------------------------------userdict /defaultpacking currentpacking put true setpackingsystemdict beginuserdict /Adobe_screens_AI5 13 dict dup beginput/initialize{	Adobe_screens_AI5 begin	/screenid		deviceDPI 600 gt composite? not or		{		-1		}		{			deviceDPI currentScreenFreq 			dup dup 60 ge exch 150 le and deviceDPI 300 le and		{			pop 60		} if		div 1.41421 div 0.5 add cvi		} ifelse	def	% (currentscreen parms are: ) print currentscreen pop == ==% (devicedpi= ) print deviceDPI ==% (screenid= ) print screenid ==% (composite?= ) print composite? ==% (vertDPI= ) print 0 72 matrix defaultmatrix dtransform dup mul exch dup mul add sqrt ==	2 screenid eq	{		/customsize 16 def		/customdata /customdata2 def		setcustomscreen	} if		3 screenid eq	{		/customsize 24 def		/customdata /customdata3 def		setcustomscreen	} if		4 screenid eq	{		/customsize 16 def		/customdata /customdata4 def		setcustomscreen	} if		5 screenid eq	{		/customsize 20 def		/customdata /customdata5 def		setcustomscreen	} if		6 screenid eq	{		/customsize 24 def		/customdata /customdata6 def		setcustomscreen	} if		7 screenid eq	{		/customsize 28 def		/customdata /customdata7 def		setcustomscreen	} if		8 screenid eq	{		/customsize 16 def		/customdata /customdata8 def		setcustomscreen	} if} def/terminate{	currentdict Adobe_screens_AI5 eq	{		end	} if} def/setcustomscreen{	deviceDPI customsize div 0	{		1 add 2 div customsize mul cvi exch		1 add 2 div customsize mul cvi exch		customsize mul add		customdata load exch get 256 div	} setscreen} def/customdata2 28 28 mul string defcurrentfile customdata2 readhexstring4180E8694988E2634382EA6B4B8AE061A01939C8A81737C2A21B3BCAAA1636C0F8795998F6775796FA7B5B9AF57656952ED8B80727D6B60F2FDABA0626D5B50E4E8DE6674786EE6F4F8EE5664685ED6EAD1434C6A61F3FCEAE1232C5A51E3ECDF3745493FE7F5F9EF1725291FD7E5E9D24D3B30C2CDEBE0222D1B10A2ADDBD044483EB6C4C8BE1624281E96A4A89E364A31C3CCBAB1535C1A11A3AC9A91838C3FB7C5C9BF4755594F97A5A99F778589730DBBB0525D4B40D2DD9B90828D7B710508FE4654584EC6D4D8CE7684887EF70AF1131C4A41D3DCCAC1333C7A72040CFF0715190FC7D5D9CF2735392FF80609F21D0B00929DCBC0323D2B20B2BDFBF01000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata3 28 28 mul string defcurrentfile customdata3 readhexstring011DC7F5E73D0421CBF3E43A021EC8F6E83E0522CCF2E43A2B648BC4A0762F688AC39E732C658CC5A177306989C29D72D5B6521A6192D9B55219608FD6B6531B6193DAB451185F8FFCEE440C28D2FCED430B27D1FDEF450C29D3FBEC420A26D0BEA77D366F83BCA77C356E87BFA87E377082BBA67B346D86145B99E0AE4A125998DFB14E155C9AE1AD4A115897DEB04D0623CDF4E63C0420CAF8EA400723CDF4E53B031FC9F7E93F316988C19F752E678EC6A378326A88C09F742D668DC6A278DBB350175E91D8B8551C6395DCB24F165D90D7B7541C6294FAEC420925CFFFF1470E2BD5F9EB410824CEFEF0460D2AD4BAA57A336C85BEAA80397180B9A479336B84BDA97F387181105797DDAF4C145A9CE3AB480F5696DDAE4B13599BE2AC49021EC8F6E83E0522CCF2E43A011DC7F5E73D0421CBF3E43A2C658CC5A177306989C29D722B648BC4A0762F688AC39E73D6B6531B6193DAB451185F8FD5B6521A6192D9B55219608FFDEF450C29D3FBEC420A26D0FCEE440C28D2FCED430B27D1BFA87E377082BBA67B346D86BEA77D366F83BCA77C356E87155C9AE1AD4A115897DEB04D145B99E0AE4A125998DFB14E0723CDF4E53B031FC9F7E93F0623CDF4E63C0420CAF8EA40326A88C09F742D668DC6A278316988C19F752E678EC6A378DCB24F165D90D7B7541C6294DBB350175E91D8B8551C6395F9EB410824CEFEF0460D2AD4FAEC420925CFFFF1470E2BD5B9A479336B84BDA97F387181BAA57A336C85BEAA803971800F5696DDAE4B13599BE2AC49105797DDAF4C145A9CE3AB4800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata4 28 28 mul string defcurrentfile customdata4 readhexstring1139B8E0FAD2531B133BBAE2F8D05119417180A6AE9A7B4B437382A5AD987949C08867272F6F92CAC28A66262E6E90C8E8DE5F070F37B6F2EADD5E060E36B5F0FED6571F173FBEE6FDD5561E163EBDE5AB9E7F4F477786A1A99D7E4E467685A32C6C96CEC68E62222A6A95CDC58D64240C34B3F6EED95A020A32B1F5EDDB5C04143CBBE3F9D1521A123AB9E1FBD3541C447483A4AC997A4A427281A7AF9B7C4CC38B65252D6D91C9C1896828307093CBEBDC5D050D35B4F1E9DF60081038B7F3FCD4551D153DBCE4FFD758201840BFE7A89C7D4D457584A2AA9F8050487887A0296994CCC48C63232B6B97CFC78F61210931B0F4ECDA5B030B33B2F7EFD85901000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata5 28 28 mul string defcurrentfile customdata5 readhexstring010B34C3EBFCF7CE3F16020C35C4EDFBF6CD3E15102552A4D6EADDB5632B112654A5D5EADCB3622A3958768499C19E8C7C5E3A59778498C19D8B7B5DC8A9937047334C7587AFC9AA936F46324B7485AEF1E5BC6B1E0A2351A3D8F2E4BC6A1E092351A2D7FFF9D14219050F38C6EFFEF9D04118040E37C6EFE8E0B7662D142856A8D3E7DFB7652D132856A7D4BF9C8E7F603D5B7A8195BE9A8E7E603C5B798297314A7389B2CCAD906D442F497289B1CBAC926E4508214FA1DBF4E2B9671B07204EA0DAF4E3BA691C030D36C5EDFBF6CD3F16010C34C3ECFDF8CF4017122654A6D4E9DDB4622A112553A5D6EBDEB5642C3B59788397C09C8B7C5D3A58778599C29E8C7D5FCAAB926E46314B7486AFC8AA947048334D7587B0F2E4BB691D082250A1D8F1E6BD6B1F0A2452A3D9FDF8CF4118030E36C5EEFFFAD1421A050F38C7F0E6DFB6642C132755A7D3E8E1B8662E152957A8D2BE9A8D7E5F3B5A798296BF9B8F80613D5C7B80952F487188B1CAAC916D443049728AB3CCAE906C43061F4D9FDAF3E2BA681C07214FA0DBF5E1B8671A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata6 28 28 mul string defcurrentfile customdata6 readhexstring081A44B6E0F2FDECC150250C091B45B6E1F3FCEBC04F240C1D336199C7D8DCD3A56C37221E33619AC8D7DBD2A46B36214864798091AEB1958C7E694C49657A8190ADB0948B7D684BB99D8475593C405C7888A1BEBA9E8574583B3F5B7888A0BDE4CBAA712E1215326098CFE8E4CCA9712D1114315F97CEE7F5F1C6552B04071943B5DFFAF6F0C6542A03061842B4DEF9FFEDC352270E0B1C47B8E3F4FEECC251260D0A1C46B7E2F4DAD5A76E39232035639CCAD5D9D4A66D38231F34629BC9D6AF938E806A4E4A677C838FABAE928D7F694D4A667B828FAC3E5A778AA3BFBC9F8772563A3D597689A2BEBB9F8673573A14305E97D1EAE6CDA76F2B0F132F5D96D0E9E5CDA8702C10051742B3DDFCF8EEC4522801041641B2DDFBF7EFC5532902091B45B6E1F3FCEBC04F240C081A44B6E0F2FDECC150250C1E33619AC8D7DBD2A46B36211D336199C7D8DCD3A56C372249657A8190ADB0948B7D684B4864798091AEB1958C7E694CBA9E8574583B3F5B7888A0BDB99D8475593C405C7888A1BEE4CCA9712D1114315F97CEE7E4CBAA712E1215326098CFE8F6F0C6542A03061842B4DEF9F5F1C6552B04071943B5DFFAFEECC251260D0A1C46B7E2F4FFEDC352270E0B1C47B8E3F4D9D4A66D38231F34629BC9D6DAD5A76E39232035639CCAD5AE928D7F694D4A667B828FACAF938E806A4E4A677C838FAB3D597689A2BEBB9F8673573A3E5A778AA3BFBC9F8772563A132F5D96D0E9E5CDA8702C1014305E97D1EAE6CDA76F2B0F041641B2DDFBF7EFC5532902051742B3DDFCF8EEC452280100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop pop/customdata7 28 28 mul string defcurrentfile customdata7 readhexstring01061B44B7E1F5FEFBE6BD4A210C01071B45B8E1F6FDFBE6BC4A200B09132A54A7D1EAF5EED9B05D331609142B55A8D2EAF4EED9AF5C32161D2D3D6993C1CBE0CEC59B7140301E2E3D6A93C0CADFCDC49A713F3047576C7B828DA2B6A48F867E6F5A48576C7C828CA1B6A38F867E6E59BAAA958A78634E4451667A8498ADBAAB968977624E4350657A8398ADE3D4C99F7539251A273C6892C2D7E4D4C89E7539241A273B6891C1D6F8F2DDB460371005122A53A7D0ECF9F2DDB360360F05122953A6D0EBFFFDE8BE4C220D03081D46B9E3F7FFFCE7BD4B210D02071C46B8E2F7F3F0DBB15E34180B152C56A9D3E8F3EFDAB05D34170A142C55A9D2E9DFCCC69C7341321F2F3F6B94BFC9DECCC59C7241311F2E3E6A94BFCAB5A38E8780705B49596D7D808BA0B4A28D877F6F5B48586D7C818BA043506479859AAFBCAC978876614C424F64798499AEBBAB968977624D19263B6791C3D8E5D6C79D73372318253A6690C3D7E5D5C79E74382304112952A5CFEDFAF0DBB25E350E03102851A5CEECF9F1DCB25F360E01071B45B8E1F6FDFBE6BC4A200B01061B44B7E1F5FEFBE6BD4A210C09142B55A8D2EAF4EED9AF5C321609132A54A7D1EAF5EED9B05D33161E2E3D6A93C0CADFCDC49A713F301D2D3D6993C1CBE0CEC59B71403048576C7C828CA1B6A38F867E6E5947576C7B828DA2B6A48F867E6F5ABAAB968977624E4350657A8398ADBAAA958A78634E4451667A8498ADE4D4C89E7539241A273B6891C1D6E3D4C99F7539251A273C6892C2D7F9F2DDB360360F05122953A6D0EBF8F2DDB460371005122A53A7D0ECFFFCE7BD4B210D02071C46B8E2F7FFFDE8BE4C220D03081D46B9E3F7F3EFDAB05D34170A142C55A9D2E9F3F0DBB15E34180B152C56A9D3E8DECCC59C7241311F2E3E6A94BFCADFCCC69C7341321F2F3F6B94BFC9B4A28D877F6F5B48586D7C818BA0B5A38E8780705B49596D7D808BA0424F64798499AEBBAB968977624D43506479859AAFBCAC978876614C18253A6690C3D7E5D5C79E74382319263B6791C3D8E5D6C79D73372303102851A5CEECF9F1DCB25F360E04112952A5CFEDFAF0DBB25E350Epop pop/customdata8 28 28 mul string defcurrentfile customdata8 readhexstring050F2747B6D6EEF8FEF4DCBC4D2D1507111D375F9EC6E0E9EBE6CCA4653D1F132939556F8EA8C1D1D3C3AE9475573B2B4961717D808999B1B39B8B867F73634BB8A090827A6A5A42445C6C7C8492A2BAD8C8AA97785232222434546E8DACCADAF0E2CFA768401A0A0C1C365E9DC5E4F2FAF7DFBF50301802040E2646B5D5EDFCFFF5DDBD4E2E160806102848B7D7EFF9EAE7CDA5663E2014121E38609FC7E1E8D2C2AF9576583C2C2A3A56708FA9C0D0B29A8A878074644C4A62727E818898B0435B6B7B8593A3BBB9A19183796959412333536D8CADCBDBD9C9AB96775131210B1B355D9CC4E5F3F1E3CEA6673F1909030D2545B4D4ECFDFBF6DEBE4F2F1701000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000pop popendenddefaultpacking setpacking%%EndResource% ------------------------------------------------------%%BeginResource: procset Adobe_typography_AI5 1.0 1%%Title: (Typography Operators)%%Version: 1.0 1%%CreationDate:(03/26/93) ()%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)% ------------------------------------------------------currentpacking true setpackinguserdict /Adobe_typography_AI5 54 dict dup beginput/initialize	% varsDict mainDict initialize -{	begin	% begin main procset	begin	% begin vars procset	Adobe_typography_AI5 begin	Adobe_typography_AI5	{		dup xcheck		{			bind		} if		pop pop	} forall	end	% take main and vars off the stack	end	end	Adobe_typography_AI5 begin} def/terminate	% - terminate -{	currentdict Adobe_typography_AI5 eq	{		end	} if} def% [ number value stream [ array for encoding modification ] modifyEncoding ==> [ modified array ]/modifyEncoding{	/_tempEncode exch ddef	% pointer for sequential encodings	/_pntr 0 ddef	{		% get bottom object		counttomark -1 roll		% is it a mark ?		dup type dup /marktype eq		{			% exit			pop pop exit		}		{			% ... object ... type ....			% insert if a nametype			/nametype eq			{				% insert the name at _pntr and increment pointer				_tempEncode /_pntr dup load dup 3 1 roll 1 add ddef 3 -1 roll				put			}			{				% reset _pntr if it's a number				/_pntr exch ddef			} ifelse		} ifelse	} loop	% return the modified encoding	_tempEncode} def/TE	% Set std platform encoding 	% (encoding pairs) TE -{	StandardEncoding 256 array copy modifyEncoding	/_nativeEncoding exch def} def% re-define font% expected arguments% for 'normal fonts : % [ /_Helvetica-Bold/Helvetica-Bold direction fontScript defaultEncoding TZ%% for cartographic, pictographic, and expert fonts :% [ ... number value stream ... /_Symbol/Symbol %	direction fontScript defaultEncoding TZ% for blended fonts w/ default encoding :% [ /_AdobeSans_20ULig1XCond-Bold/AdobeSans %	direction fontScript defaultEncoding [ w0 w1 ... wn ] TZ% for blended fonts w/ special encoding :% [ ... number value stream ... /_AdobeSans_20ULig1XCond/AdobeSans %	direction fontScript defaultEncoding [ w0 w1 ... wn ] TZ/TZ{	% set weight vector (if present)	dup type /arraytype eq	{		/_wv exch def	}	{		/_wv 0 def	} ifelse	% platform dependent coding flag	/_useNativeEncoding exch def	% pop fontScript & direction	pop pop	% create a new dictionary with length	% equal to original dictionary length + 2	% copy all the key/value pairs except FID	% call makeblended font with the weight values if _wv is an array	findfont _wv type /arraytype eq	{		_wv makeblendedfont	} if	dup length 2 add dict	begin	% copy all the values but the FID	% into the new dictionary	mark exch	{		1 index /FID ne		{			def		} if		cleartomark mark	} forall	% discard last mark	pop	% define FontName	/FontName exch def	% if no re-encoding stream is present	% then if the base encoding vector of the font	% is the same as StandardEncoding	% and the use platform encoding flag is true	% then install AI platform encoding	% else leave the base encoding in effect	counttomark 0 eq	{		1 _useNativeEncoding eq		{			/Encoding _nativeEncoding def		} if		% clean up		cleartomark	}	{		% custom encoding to be done		% start off with a copy of the font's standard encoding		/Encoding load 256 array copy		modifyEncoding /Encoding exch def	} ifelse	FontName currentdict	end	% register the new font	definefont pop} def% text painting operators/tr	% string tr ax ay string {	_ax _ay 3 2 roll} def/trj	% string trj cx cy fillchar ax ay string {	_cx _cy _sp _ax _ay 6 5 roll} def/a0{	/Tx	% text							% textString Tx -	{		dup		currentpoint 3 2 roll		tr _psf		newpath moveto		tr _ctm _pss	} ddef	/Tj	% justified text				% textString Tj -	{		dup		currentpoint 3 2 roll		trj _pjsf		newpath moveto		trj _ctm _pjss	} ddef} def/a1{	/Tx	% text							% textString Tx -	{		dup currentpoint 4 2 roll gsave		dup currentpoint 3 2 roll		tr _psf		newpath moveto		tr _ctm _pss		grestore 3 1 roll moveto tr sp	} ddef	/Tj	% justified text				% textString Tj -	{		dup currentpoint 4 2 roll gsave		dup currentpoint 3 2 roll		trj _pjsf		newpath moveto		trj _ctm _pjss		grestore 3 1 roll moveto tr jsp	} ddef} def/e0{	/Tx	% text							% textString Tx -	{		tr _psf	} ddef	/Tj	% justified text				% textString Tj -	{		trj _pjsf	} ddef} def/e1{	/Tx	% text							% textString Tx -	{		dup currentpoint 4 2 roll gsave		tr _psf		grestore 3 1 roll moveto tr sp	} ddef	/Tj	% justified text				% textString Tj -	{		dup currentpoint 4 2 roll gsave		trj _pjsf		grestore 3 1 roll moveto tr jsp	} ddef} def/i0{	/Tx	% text							% textString Tx -	{		tr sp	} ddef	/Tj	% justified text				% textString Tj -	{		trj jsp	} ddef} def/i1{	W N} def/o0{	/Tx	% text							% textString Tx -	{		tr sw rmoveto	} ddef	/Tj	% justified text				% textString Tj -	{		trj swj rmoveto	} ddef} def/r0{	/Tx	% text							% textString Tx -	{		tr _ctm _pss	} ddef	/Tj	% justified text				% textString Tj -	{		trj _ctm _pjss	} ddef} def/r1{	/Tx	% text							% textString Tx -	{		dup currentpoint 4 2 roll currentpoint gsave newpath moveto		tr _ctm _pss		grestore 3 1 roll moveto tr sp	} ddef	/Tj	% justified text				% textString Tj -	{		dup currentpoint 4 2 roll currentpoint gsave newpath moveto		trj _ctm _pjss		grestore 3 1 roll moveto tr jsp	} ddef} def% font operators% Binding/To	% begin text 					% bindType To -{	pop _ctm currentmatrix pop} def/TO	% end text					% TO -{	iTe _ctm setmatrix newpath} def% Text paths/Tp	% begin text path				% a b c d tx ty startPt Tp -{	pop _tm astore pop _ctm setmatrix	_tDict begin	/W	{	} def	/h	{	} def} def/TP	% end text path					% TP -{	end	iTm 0 0 moveto} def% Render mode & matrix operators/Tr	% begin render					% render Tr - {	_render 3 le	{		currentpoint newpath moveto	} if	dup 8 eq	{		pop 0	}	{		dup 9 eq		{			pop 1		} if	} ifelse	dup /_render exch ddef	_renderStart exch get load exec} def/iTm	% internal set text matrix		% - iTm -	(uses _tm as implicit argument){	_ctm setmatrix _tm concat 0 _rise translate _hs 1 scale} def/Tm	% set text matrix				% a b c d tx ty Tm -{	_tm astore pop iTm 0 0 moveto} def/Td	% translate text matrix 		% tx ty Td -{	_mtx translate _tm _tm concatmatrix pop iTm 0 0 moveto} def/iTe	% end render					% - iTe -{	_render -1 eq	{	}	{		_renderEnd _render get dup null ne		{			load exec		}		{			pop		} ifelse	} ifelse	/_render -1 ddef} def% Attributes/Ta	% set alignment					% alignment Ta -{	pop} def/Tf	% set font name and size		% fontname size Tf -{	dup 1000 div /_fScl exch ddef% was  (bh 11/23/93)% 	exch findfont exch scalefont setfont%	selectfont} def/Tl	% set leading					% leading paragraphLeading Tl -{	pop	0 exch _leading astore pop} def/Tt	% set user tracking				% userTracking Tt -{	pop} def/TW	% set word spacing				% minSpace optSpace maxSpace TW -{	3 npop} def/Tw	% set computed word spacing		% wordSpace Tw{	/_cx exch ddef} def/TC	% set character spacing			% minSpace optSpace maxSpace TC -{	3 npop} def/Tc	% set computed char spacing 	% charSpace Tc -{	/_ax exch ddef} def/Ts	% set super/subscripting (rise)	% rise Ts -{	/_rise exch ddef	currentpoint	iTm	moveto} def/Ti	% set indentation				% firstStartIndent otherStartIndent stopIndent Ti -{	3 npop} def/Tz	% set horizontal scaling		% scalePercent Tz -{	100 div /_hs exch ddef	iTm} def/TA	% set pairwise kerning			% autoKern TA -%	autoKern = 0 -> no pair kerning%			 = 1 -> automatic pair kerning{	pop} def/Tq	% set hanging quotes			% hangingQuotes Tq -%	hangingQuotes 	= 0 -> no hanging quotes%			 		= 1 -> hanging quotes{	pop} def/Th	% set hyphenation				% hyphenate? limitLines? minLead minTail maxLines Th -% 	hyphenate?	= 0 -> don't hyphenate%				= 1 -> do hyphenate% 	limitLines? = 0 -> no limit%				= 1 -> limit consecutive hyphenated lines%	minLead		Closest hyphen to beginning of word (0..n)% 	minTail		Closest hyphen to end of word (0..n)% 	maxLines	Maximum number of consecutive hyphenated lines (1..n){	pop pop pop pop pop} def% Text Bodies/TX{	pop} def% /Tx	% non-justified text			% textString Tx -% /Tj	% justified text				% textString Tj -/Tk	% kern							% autoKern kernValue Tk -%  	autoKern = 0 -> manual kern, = 1 -> auto kern%	kernValue = kern value in em/1000 space{	exch pop _fScl mul neg 0 rmoveto} def/TK	% non-printing kern				% autoKern kernValue TK -{	2 npop} def/T*	% carriage return & line feed	% - T* -{	_leading aload pop neg Td} def/T*-	% carriage return & negative line feed	% - T*- -{	_leading aload pop Td} def/T-	% print a discretionary hyphen	% - T- -{	% backup the pen position by the letterspacing so that	% full-justified, auto-hyphenated lines display properly	% [John Farmer 11/18/95]	_ax neg 0 rmoveto	_hyphen Tx} def/T+	% discretionary hyphen hyphen	% - T+ -{} def/TR	% reset pattern matrix 			% a b c d tx ty TR -{	_ctm currentmatrix pop	_tm astore pop	iTm 0 0 moveto} def/TS	% special chars					% textString justified TS -{	currentfont 3 1 roll	/_Symbol_ _fScl 1000 mul selectfont		0 eq	{		Tx	}	{		Tj	} ifelse	setfont} def% Tab extensions for 5.5 (Glenn Reid 1/26/94)/Xb % begin tab definitions			% <unused> tabCount Xb -{	pop pop} def/Tb /Xb load def/Xe % one tab stop					% leader(char) decimal(char) type(int) distance Xe -{	pop pop pop pop} def/Te /Xe load def/XB % end tab definitions			% - XB -{} def/TB /XB load defcurrentdict readonly popendsetpacking%%EndResource% ------------------------------------------------------%%BeginResource: procset Adobe_blend_AI5 1.4 0%%Title: (Adobe Illustrator (R) Version 5.0 Blend ProcSet)%%Version: 1.4 0%%CreationDate: (11/19/93) ()%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)% ------------------------------------------------------userdict /defaultpacking currentpacking put true setpackinguserdict /Adobe_blend_AI5 70 dict dup beginput/bd{	bind def} bind def/xs{	exch store} bd% null procedure/nullProc{	{	}} def/initialize	% varsDict mainDict initialize -{	pop pop	Adobe_blend_AI5 begin		Adobe_blend_AI5_vars begin			% define _contoneDevice if necessary			/_contoneDevice where			{				pop			}			{				/_contoneDevice false def				} ifelse								% define dpi threshold for fast case (tRectOK == true) if necessary			/_dpiThreshold where			{				pop			}			{					/_dpiThreshold 600 def			} ifelse						% define screen frequency threshold for fast case (tRectOK == true) if necessary			/_screenFreqThreshold where			{				pop			}			{					/_screenFreqThreshold 150 def			} ifelse						% define "tile w/ rects" flag			/tRectOK? deviceDPI _dpiThreshold le currentScreenFreq _screenFreqThreshold le and _contoneDevice not and def	% we need an inverted current transfer function	% to use image with color data values	% new transfer inversion procedure to call system transfer procedures	% also moved dfn to here instead of in prolog body (5.0.1 fix bh 10/25/93)	/invertXfer	{		[		{			1 exch sub				} /exec load systemdict/currenttransfer get exec /exec load				] cvx systemdict/settransfer get exec			} bd			/spotDict 3 dict dup begin				/nSpots 2 def				/spot1 7 dict def				/spot2 7 dict def			end			def			% pick up systemdict definitions for setgray, fill, and image if doing separations			composite?			{				/_setgray_ /setgray load def				/_fill_ /fill load def				/_image_ /image load def			}			{				/_setgray_ systemdict/setgray get def				/_fill_ systemdict/fill get def				/_image_ systemdict/image get def			} ifelse		} bd		/terminate		{			currentdict Adobe_blend_AI5_vars eq			{			end			currentdict Adobe_blend_AI5 eq			{			end		} if	} if} bd% define _compositeSpotDevice if necessary/_compositeSpotDevice where{	% force composite? on if _compositeSpotDevice is enabled	begin		_compositeSpotDevice 0 ne {userdict /composite? true put} if	end}{	/_compositeSpotDevice 0 def	} ifelse	/nullString () def/d255 256 array def	% 0/255, 1/255, 2/255, etc.0 1 255{	d255 exch dup 255 div put} bind for/d255- 256 array def	% 255/255, 254/255, 253/255, etc0 1 255{	d255- exch 1 d255 2 index get sub put} bind for/dUserSpace matrix defaultmatrix defcurrentdict /Adobe_blend_AI5_vars 89 dict dup beginput{	/f /F /s /S /b /B}{	null def} bind forall% utility scratch string/byte 1 string def% use this for temporary save...restoring/sSave null def/setSSave{	save /sSave exch store} bind def% stubs for on-the-fly defined procedures/Bm null def/doBlend null def/startC? false def/endC? false def/fCMYK? null def/startTint 0 def/endTint 0 def/bSMatrix matrix def/bUMatrix matrix def/dMatrix matrix def/inLine? true def/pTState? false def/bHi? false def/yHi 0 def/xHi 0 def% level 1 typesetters w/ image operator problems% 	noImg == true -> don't ever call the image operator/noImg /lv1Fix where{	pop lv1Fix}{	false} ifelsedef/ccAry1 5 array def/ccTint 0 def/spotColor? false def/colorimage? true def[/tint1Data/tint2Data/spotDict/bAxis/ubAxis/pChange/optimize?/nSamples/sInc/blendProc/_bn/xBCInc/yBCInc/bInc/bRender/cBName/cBType/nColors/color?/blend?/colorType/cData/cDataLen/bDataLen/rampPoint/midPoint/endPoint/blendLength/blackData/yeData/mgData/cyData/cnt1/ndx/_fill/tmpcounttomark{	null def} bindrepeatpopcurrentdictendcurrentdictendexchbeginbegin% define utilities and 'getRData template% all get data procs need these% utility procedures/unitSq{	0 0 moveto 0 1 lineto 1 1 lineto 1 0 lineto closepath} bd/gMark{	counttomark 2 add -1 roll} bd/setCustomColor	%	c m y k name tint setCustomColor -{	dup /ccTint exch store	1 exch sub 6 1 roll	ccAry1 astore	exch setcustomcolor} bd/currentCustomColor	% - currentCustomColor - c m y k name tint{	ccAry1 aload pop ccTint} bd% allow override of /nsetcustomcolor/nsetcustomcolor where {	pop}{	/nsetcustomcolor	% 	c m y k spotDict nsetcustomcolor -	{		pop setcmykcolor		} bd} ifelse% allow override of /nsetcustomcolorend/nsetcustomcolorend where {	pop}{	/nsetcustomcolorend	% 	- nsetcustomcolorend -	{	} bd} ifelse/setBSpace{	newpath bUMatrix astore concat unitSq} bd/setCStop{	dup 0 eq	{		pop				% hack to set a fake spot color for the black->spot, spot->black cases		spotColor?			{			dup 1 exch sub /ccTint exch def			ccAry1 4 /Black put			} if		setgray	}	{		1 eq		{			setcmykcolor		}		{			% *** check for force cmyk			composite? not colorType 2 lt and			{				forceCMYK			}			{				setCustomColor			} ifelse		} ifelse	} ifelse} bd% *** utility to convert gray value into 8 byte string/makeByte{	/tmp 0 store	255 mul cvi	8 string 8	{		dup tmp 3 index put /tmp tmp 1 add store	} repeat	exch pop} bd/setImgSpace{	cDataLen 1 8	2 index 0 0 1 0 0 dMatrix astore} bd/bwImage{	% (in bwImage) ==	setImgSpace cData /_image_ load	{		exec	} stopped	{		$error /errorname get /undefinedresult ne		{			stop		}		{			pop pop pop pop pop		} ifelse	} if} bd% define these only for level 2level2?{	/bFill	{		% 		(in level2 bFill\n) print		_fill	} def	/bCImg	{%		(in level2 bCImg\n) print		/cDataLen bDataLen store		setImgSpace		setSSave		expandSpot		cyData mgData yeData cData		expandCMYK		true 4 spotDict	% push spot dict as well		{			ncolorimage		} stopped		{			$error /errorname get /undefinedresult ne			{				stop			}			{				10				{					pop				} repeat			} ifelse		} if		sSave restore	} bd} if/expandOne	% input is a single integer or string: output is a string{			dup type /stringtype ne			{				% build a new string with constant value				cDataLen string				exch				% string value				% we don't have to fill the string if the value is 0				dup 0 ne				{					255 mul cvi					% string value					0 1 cDataLen 1 sub					{						3 copy						% string value ndx string value ndx						exch put pop					} for				} if				pop			} if} bd/expandSpot{	spotColor?	{		spotDict begin			spot1 begin				tintImage type /nulltype ne				{					tintImage expandOne /tintImage exch def				} if		 	end			spot2 begin				tintImage type /nulltype ne				{					tintImage expandOne /tintImage exch def				} if		 	end		end	} if} bd% scans arguments (cmyk) and substitutes strings of the appropriate length for integer constants/expandCMYK{%	(in expandCMYK) ==	% check all color values for constants	% c m y k ==> c m y k (all strings)	4	{		expandOne 4 1 roll	} repeat} bd% define 'colorimage emulation % only for level 1 and no 'colorimage present	/colorimage where dup{	% *** (using direct calls to colorimage\n) print	exch pop	% if it's there we can use it directly		% allow override of /ncolorimage	/ncolorimage where	{		pop	}	{		/ncolorimage {pop colorimage} bd % discard spot dict arg 	} ifelse} ifnot{	/ncolorimage where 	{		pop	}	{		% *** (defining level 1 colorimage emulation\n) print		/colorimage? false store		/ncolorimage		{			% discard true 4 spotDict arguments			pop pop pop			% *** wrapped in save...restore to reclaim vm		setSSave		% we re-define colorvariables here		% because we might be doing the 1 byte case		/blackData xs		/yeData xs		/mgData xs		/cyData xs		/cnt1 0 store		[		byte dup 0		cyData dup type /stringtype eq		{			/cnt1 cvx /get cvx d255 /exch cvx /get cvx .3 /mul cvx		}		{			.3 mul		} ifelse		mgData dup type /stringtype eq		{			/cnt1 cvx /get cvx d255 /exch cvx /get cvx .59 /mul cvx		}		{			.59 mul		} ifelse		yeData dup type /stringtype eq		{			/cnt1 cvx /get cvx d255 /exch cvx /get cvx .11 /mul cvx		}		{			.11 mul		} ifelse		blackData dup type /stringtype eq		{			/cnt1 cvx /get cvx d255 /exch cvx /get cvx		} if		/add cvx /add cvx /add cvx 1 /exch cvx /sub cvx		/dup cvx 0 /lt cvx		{			pop 0		} /if cvx		/dup cvx 1 /gt cvx		{			pop 1		} /if cvx		255 /mul cvx /cvi cvx		% *** check for out of range		256 /mod cvx		/dup cvx 0 /lt cvx		{			pop 0		} /if cvx		/put cvx		/cnt1 dup cvx 1 /add cvx /store cvx		] cvx		bind			_image_ 		sSave restore	} bd	} ifelse} if% define these only for level 1level2? not{	/bCImg	{		%		(entry level 1 bCImg\n) print		/cDataLen bDataLen store		setImgSpace		setSSave		expandSpot		cyData mgData yeData cData		colorimage? 		{			expandCMYK		} if	% (no need to expand if we have our own ncolorimage...)		true 4 spotDict		{			ncolorimage		} stopped		{			$error /errorname get /undefinedresult ne			{				stop			}			{				10				{					pop				} repeat			} ifelse		} if		sSave restore		% *** (exit level 1 bCImg\n) print		} bd	/bwFill	{		%	(in bwFill) ==		setSSave		/cDataLen 8 store		/cData currentgray makeByte store		bwImage		sSave restore	} bd	/c1ImgFill	{		%		(in c1ImgFill) ==		setSSave		/cDataLen 8 store		setImgSpace		spotColor?		{			spotDict begin				spot1 begin					currentCustomColor makeByte /tintImage exch def					/name exch def					/spot_K exch def					/spot_Y exch def					/spot_M exch def					/spot_C exch def				end				spot2 initSpotData			end		} if		currentcmykcolor		4		{			makeByte 4 1 roll		} repeat		true 4 spotDict		{			ncolorimage		} stopped		{			$error /errorname get /undefinedresult ne			{				stop			}			{				10				{					pop				} repeat			} ifelse		} if		sSave restore	} bd	/bFill	noImg	{		{			_fill		}	}	{		{			color?			{				c1ImgFill			}			{				bwFill			} ifelse		}	} ifelse	bd} if% end level 1 specific procedures% *** composite procedures% composite? not { setScratchSave } ifcomposite?{	% *** (defining composite blend data procedures\n) print	% *** we're on composite page so don't have to worry	% *** about knockout, etc.	/bCFun	{		% *** (in composite bCFun\n) print		% *** (color? = ) print color? ==		% *** (spotColor? = ) print spotColor? ==		color?		{			cyData dup type /stringtype eq			{				/ndx cvx /get cvx d255 /exch cvx /get cvx			} if			mgData dup type /stringtype eq			{				/ndx cvx /get cvx d255 /exch cvx /get cvx			} if			yeData dup type /stringtype eq			{				/ndx cvx /get cvx d255 /exch cvx /get cvx			} if			cData dup type /stringtype eq			{				/ndx cvx /get cvx d255 /exch cvx /get cvx			} if			% store tint values in the spot dicts			spotColor?			{				spotDict begin					/spotDict cvx /begin cvx					spot1 begin						tintImage dup type /stringtype eq						{							/ndx cvx /get cvx d255- /exch cvx /get cvx						}						{	% Invert the tintValue for constant custom ink data							dup type /nulltype ne 							{								name type /nametype ne {1 exch sub} if							} if						} ifelse					end					/spot1 cvx /tintValue 3 -1 /roll cvx /put cvx					spot2 begin						tintImage dup type /stringtype eq						{							/ndx cvx /get cvx d255- /exch cvx /get cvx						}						{	% Invert the tintValue for constant custom ink data							dup type /nulltype ne 							{								name type /nametype ne {1 exch sub} if							} if						} ifelse					end					/spot2 cvx /tintValue 3 -1 /roll cvx /put cvx					/end cvx % spotDict				end	% spotDict				/spotDict cvx				/nsetcustomcolor cvx			}			{				/setcmykcolor cvx			} ifelse		}		{			cData /ndx cvx /get cvx			d255 /exch cvx /get cvx			/setgray cvx		} ifelse	} bd% *** new Bc for composite plate	/Bc	{		% *** (\nin composite Bc nColors = ) print		% *** nColors ==			% *** (blend? = ) print blend? ==		newpath		gsave		setBSpace		nColors 1 eq		{			% discard midPoint and rampPoint			pop pop			% *** (setting color for blend final cap : colorType = ) print colorType ==				setCStop		} if		bFill		grestore		% *** (exit Bc\n) print						} bd	/linealBm	{		/nColors dup load 1 sub store		% *** (\nin composite linealBm :  nColors = ) print nColors ==		% *** linear blend color type selection here		% *** (blend? = ) print blend? ==		newpath		gsave		setBSpace		blend?		{			linImg		}		{			bFill		} ifelse		grestore		% changed			nColors 1 gt		{			% *** (calling getRData in /linealBm\n) print			getRData		} if		% *** (exit linealBm\n)print	} bd	/rdBm	{		/nColors dup load 1 sub store		% fill the path		_fill		% *** (in composite rdBm nColors = ) print nColors ==		gsave		% set the initial blend space		% and fill the initial circle		bUMatrix astore concat		% calculate the hilite vectors in blend space		% save re-calculation in calls to 'rdBlend/'rdPrep		bHi?		{			xHi yHi bUMatrix idtransform /yHi exch store /xHi exch store			rampPoint 1 lt			{				1 rampPoint sub dup xHi mul exch yHi mul translate			} if		} if		nColors		{			% *** (in radial blend loop blend? = ) print blend? ==			% *** (rampPoint = ) print rampPoint ==			% *** (midPoint = ) print midPoint ==% *** we can skip the blend only if there's no hilite !			% image the path with radius 'rampPoint			0 0 rampPoint 0 360 arc			_fill			blend? bHi? or			{				rdBlend			} if			nColors 1 gt			{				% *** (calling getRData from end of rdBm\n) print					getRData			} if			/nColors dup load 1 sub store		} repeat		/nColors 1 store		grestore	} bd	/cGetRData	{		setCStop		/blend?		cData type /stringtype eq		dup not color? and		{			pop			cyData type /stringtype eq			mgData type /stringtype eq			yeData type /stringtype eq			or or		} if		store	} def	/cGetRData} if% composite? not { scratchSave restore } if/eCStop{	% gray 0									3	% c m y k 1								6	% c m y k (name) tint 2			8	% c m y k (name) tint 3			8			mark	1 index 3 mul 3 add dup 8 gt	{		pop 8	} if	1 roll	cleartomark} bd% *** non-composite plate specific procedures% *** define the 'getRData procedure% *** based on color separation state% *** define the cmyk or custom paramteters% composite? { setScratchSave } ifcomposite? not{	% *** (defining non-composite blend data procedures\n) print	% we don't need explicit overprint handling if its level 2	% because we're using fill for all blend caps	/knockOut	level2?	{		{			0 0 0 0 setcmykcolor _fill		}	}	{		% enforce level1 fill overprint semantics for white in gradients (bh 3/26/94)		%	noImg case is handled by similar code for _fill		/bFill noImg		{			{				_fill			}		}		{			{				_of true eq				{					currentgray 1 ne					{						bwFill					} if				}				{					bwFill				} ifelse			}		} ifelse		def		% make whiteByte 8 bytes long (bh 3/27/94)		/whiteByte 1 makeByte def		noImg		{			{				0 0 0 0 setcmykcolor _fill			}		}		{			{				% *** (in level 1 knockout\n) print				cBType 0 eq				{					% linear					setSSave					/cData whiteByte store						% whiteByte is really 8 bytes long (bh 3/27/94)					/cDataLen 8 store					bwImage					sSave restore				}				{					% radial					_fill				} ifelse			}		} ifelse	} ifelse	bd	/bCFun	{		cData dup type /stringtype ne		{			color?			{				1 exch sub			} if		}		{			/ndx cvx /get cvx			color? customColor? not and			{				d255-			}			{				d255			} ifelse			/exch cvx /get cvx		} ifelse		/_setgray_ cvx	} bd	/eCCBlend	{		% *** (in eCCBlend\n) print		% c m y k (name) tint2 3 midPoint rampPoint c m y k (name) tint1 3		% new data possibilities with change in format 06 12		% 0 0 midPoint rampPoint c m y k (name) tint1 3		% 0 0 0 0 1 midPoint rampPoint c m y k (name) tint1 3		% c m y k (name) tint2 3 midPoint rampPoint 0 0		% c m y k (name) tint2 3 midPoint rampPoint 0 0 0 0 1% *** isCMYKSep? { (customcolor tint blend on a cmyk plate\n)} { (customcolor tint blend on a custom plate\n)} ifelse print		dup 3 eq		{			% customcolor is on top			% next color stop is either custom, 0 gray, or 0 0 0 0 cmyk			pop			mark 7 1 roll			% colorSpec colorStyle midPoint rampPoint mark c m y k (name1) tint			% we do the blend using 'tint1Data if a 100% push of the current custom			% color results in black color only on the current plate			6 copy ccThrough? dup /blend? xs			{				/startC? true store				setCustomColor				customColor?				{					/cData tint1Data store					setCDataLen				} if				/endC?				3 index 3 eq				{					4 index 1 ne				}				{					false				} ifelse				store			} if			cleartomark			% colorSpec colorStyle midPoint rampPoint			stop		} if		% starts with zero gray or 0 0 0 0 cmyk		% forget the color; we're already at white !		1 eq		{			pop pop pop		} if		pop		% skip the startC		/startC? false store		% c m y k (name) tint2 3 midPoint rampPoint		% we do the blend if the next color goes through		% and if its tint is not white		6		{			8 index		} repeat		ccThrough? dup /blend? xs		{			/endC? true store			blend? not			{				stop			} if			% if it's a customcolor blend, we use 'tint1Data			customColor?			{				/cData tint1Data store				setCDataLen			} if		} if		% c m y k (name) tint2 3 midPoint rampPoint			% *** (exit evalCustomBlend\n) print	} bd	/handleOP	{		_of not		{			knockOut		} if	} bd	% added radial handle overprint proc (bh 3/26/94)	/handleROP	{		_of not		{			0 0 0 0 setcmykcolor _fill		}		{			newpath			} ifelse	} bd	/rdBm	{		/nColors dup load 1 sub store		% handle fill or overprint (bh 3/26/94) 		%	(was composite? blend? or _of not or {_fill}{newpath} ifelse		blend? 		{			_fill		}		{			handleROP		} ifelse		gsave		bUMatrix astore concat		bHi?		{			xHi yHi bUMatrix idtransform /yHi exch store /xHi exch store			rampPoint 1 lt			{				1 rampPoint sub dup xHi mul exch yHi mul translate			} if		} if		nColors		{			0 0 rampPoint 0 360 arc			blend?			{				cData type /stringtype ne bHi? not and				{					% *** invert value if 'color?					cData color?					{						1 exch sub					} if					_setgray_ 					_fill_ 				}				{					cData type /stringtype ne					{						/cDataLen 1 store						/bDataLen 1 store	% added (bh 10/12/93)					} if					rdBlend				} ifelse			}			{				% rewrote this section (bh 3/26/94)								handleROP	% handle the overprint 								% translate the radial hilight if necessary				pTState?				{					/bAxis rampPoint endPoint sub store					xHi bAxis mul yHi bAxis mul translate				} if			} ifelse							nColors 1 gt			{				getRData			} if			/nColors dup load 1 sub store		} repeat		/nColors 1 store		grestore	} bd% define resoures needed for both custom color	% and cmyk separations	% new defn of ccThrough? (bh 3/22/94)	/ccThrough?	{		gsave		pop 0 setCustomColor		currentcmykcolor		grestore		anyColor?	} bd	/forceCMYK	{		exch pop		1 exch sub 5 1 roll		4		{			4 index mul 4 1 roll		} repeat		% ***	fake Separator out to believe its white		% ***	if there's no color on the current channel		0		cCMYKData dup /cData ne		{			dup /yeData eq			{				pop 1 add			}			{				/mgData eq				{					2				}				{					3				} ifelse				add			} ifelse			0		} if		pop		index		0 eq		{			pop pop pop pop 0 0 0 0		} if		setcmykcolor		pop		/fCMYK? true store	} bd% *** end cap for cmyk separation plates	/endCapSepBc	{		% *** (entry cmyk sep end cap\n) print		% colorSpec colorStyle midPoint rampPoint		pop pop% set the final color stop		dup 0 eq		{			pop			setgray		}		{			1 eq			{				setcmykcolor			}			{				% if the colortype is 1				% then we are looking at the end of a blend				% from gray > customColor or cmyk > customColor				% to make sure it goes through				% we have to force it				colorType 1 eq				{					forceCMYK				}				{					% if the colortype is > 1 then					% we are at the end of a customcolor tint blend					% or a customcolor > customcolor blend% for a tint custom color blend we can rely					% on the normal mechanism to either put the					% color through or skip it % for a customcolor > customcolor blend					% if either or both colors went through					% we would have used forceCMYK					% to set the first color					% and fCMYK? = true										fCMYK?					{						forceCMYK					}					{						setCustomColor					} ifelse				} ifelse			} ifelse		} ifelse		currentcmykcolor anyColor? 		blend? and	% changed 'or' to 'and'	(bh 3/27/94)		{			bFill		}		{			handleOP		} ifelse		% *** (exit cmyk sep end cap\n) print	} bd} if% composite? { scratchSave restore } if/cCMYKData 0 def% *** cmyk separation procedurescomposite? dup not{	pop customColor?} ifnot{	%	customColor? { setScratchSave } if	% *** (defining cmyk blend data procedures\n) print	% which cmyk plate are we on ?	/cCMYKData	/cyData /mgData /yeData /cData	black? not	{		yellow?		{			exch		}		{			magenta?			{				3			}			{				4			} ifelse			-1 roll		} ifelse	} if	4 1 roll pop pop pop	store	% *** (current cmyk channel = ) print cCMYKData ==	/Bc	{		% *** (\nin separation Bc nColors = ) print nColors ==			% *** (blend? = ) print blend? ==		gsave		setBSpace		nColors 1 gt		{			% start cap			% *** (entry sep start cap\n) print						blend? currentcmykcolor anyColor? and			{				bFill			}			{				handleOP			} ifelse% *** (exit sep start cap\n) print		}		{			endCapSepBc		} ifelse		grestore		newpath% *** (exit Bc\n) print	} bd	/linealBm	{		/nColors dup load 1 sub store% *** (\nin cmyk sep linealBm :  nColors = ) print nColors ==		% *** linear blend color type selection here		% *** (blend? = ) print blend? ==		newpath		gsave		setBSpace		blend?		{			cCMYKData load dup type /stringtype eq			{				dup length /cDataLen xs				/cData xs				gsave				colorType 0 ne noImg not and				{					invertXfer				} if				linImg				grestore			}			{				pop bFill			} ifelse		}		{			handleOP		} ifelse		grestore% changed			nColors 1 gt		{			% *** (calling getRData in /linealBm\n) print			getRData		} if% *** (exit linealBm\n)print	} bd	/cmykGetRData	{		% *** (in cmykGetRData\n) print		% assume no forced call to setcmykcolor		/fCMYK? false store		blend?		{			% get the data in a 'stopped so we can boogie out quickly			{				cmykDataProcs colorType get exec			} stopped			pop			% *** (return from cmyk data selection\n) print			% *** (blend? = ) print blend? ==			% *** (fCMYK? = ) print fCMYK? ==			% if we are doing the blend, put the current channel data into			% cData and take its length			blend?			{				/cData cCMYKData load store				setCDataLen			} if			% on return if blend? = true and fCMYK? = true			% for a custom > 0 or a custom > 0 0 0 0 blend    colorType = 1			% setcmyk color call has been forced from custom color definition			% for a blend from custom color to custom color colorType = 3			% the first custom color does not go through and the second one does			% and we had to setcmyk color from the first custom color definition		} if		% *** (exit cmykGetRData\n) print	} def	/cmykDataProcs	[	% gray blend on cmyk plate	{		pop		% we do the blend only if		% we're on the black plate		black? dup /blend? xs		{			setgray			0		} if		pop	}	% cmyk blend on cmyk plates	{		% at this point we have the c m y k data strings or values		% and we know there's some data in the channel		% which is either a non-zero constant or a string		cCMYKData load dup type /stringtype ne		{			% current channel data is a non-zero constant			% we can use this for a fill			% special cases of 0% gray and 0 0 0 0 cmyk			% do not arise here			% *** (cmyk blend with constant data on current cmyk channel\n) print								0 0 0			cyan? not			{				4 magenta?				{					1				}				{					yellow?					{						2					}					{						3					} ifelse				} ifelse				roll			} if			% set blend? flag to false if this plate has no ink from this blend (bh 3/18/94)			4 copy add add add 0 eq			{				/blend? false store			} if						setcmykcolor			/startC? true store			/endC? true store			eCStop			stop		} if		pop		% at this point we know the channel data is a string		dup 0 eq		{			pop			% gray > ? blend on cmyk plate			setgray			% color colorStyle midPoint rampPoint		}		{			1 eq			{				% color colorStyle midPoint rampPoint c m y k				% cmyk > ? blend on cmyk plate				setcmykcolor			}			{				% *** (custom color > ? blend on cmyk plate\n) print				% custom color > ?? blend on cmyk plate				% force it to go through whether it goes through now or not				forceCMYK			} ifelse		} ifelse	} bind% customColor? { scratchSave restore } if% isCMYKSep? { setScratchSave } if% tint customcolor blend on cmyk plate	/eCCBlend load% (customcolor or black) to (customcolor or black) blend on cmyk plate	%	at least one of the colors is a custom color	{		% (customcolor|black > customcolor|black blend on cmyk plate\n) print		% if it's a radial, swap tint data		cBType 1 eq		{			tint1Data tint2Data			/tint1Data xs			/tint2Data xs		} if		0 eq		{			% a gray color spec			%			(first color is a gray value) ==			black?			{				setgray			}			{				0 0 0 4 -1 roll 1 exch sub setcmykcolor			} ifelse			% c m y k (name2) tint 2|3 midPoint rampPoint			% we do the blend if we're on the black plate OR			% if a 100% push of the next custom			% color results in color on the current plate			% copy the next custom color to preserve stack			black?			{				/blend? true store			} if			6			{				8 index			} repeat			ccThrough?			{				/blend? true store			}			{				black?				{					/cData tint1Data store					setCDataLen				}				{					/blend? false store				} ifelse			} ifelse		}		{			mark 7 1 roll			% c m y k (name2) tint 2|3 midPoint rampPoint mark c m y k (name1) tint			% 100% push of the current custom			% color results in any black on the current plate ?			6 copy ccThrough?			{				% *** (first customcolor goes through\n) print								% at this point if blend? = true				% we can assume the first color is going through and stop				% we force the color to cmyk here				% even though it goes through				% to set the 'fCMYK? flag				% for use in the blend cap				% if the second color does not go through				forceCMYK				pop				stop			} if			% *** (first customcolor does not go through\n) print				% the first custom color doesn't go through			% we must now test the next custom color			% we have to keep the first customcolor around			% to possibly force a color set using setcmykcolor			% to get the start cap right			% get colortype of next stop			9 index 0 eq			{				%				(2nd stop is a gray value) ==				black? dup /blend? xs				{					% set the startcap color to white					pop 1 setgray					/cData tint2Data store					setCDataLen					0				} if				pop			}			{				% otherwise a custom color spec (colortype==3)%				(2nd stop is a custom color) ==				% c m y k (name2) tint 2|3 midPoint rampPoint mark c m y k (name1) tint				% we do the blend if a 100% push of the next custom				% color results in color on the current plate				% copy the next custom color to preserve stack				/blend?				6				{					16 index				} repeat				ccThrough?				store				% if blend? is true now,				% the first color doesn't go through and the second does				blend?				{					% *** (second customcolor goes through\n) print						% force setcmykcolor to the first color					forceCMYK				} if			} ifelse			% *** blend? not { (second customcolor does not go through\n) print	 } if			cleartomark		} ifelse	} bind	] def	/cmykGetRData} if% *** custom color separation procedurescomposite? dup not{	pop isCMYKSep?} ifnot{	% *** (defining custom blend data procedures\n) print	% end cap for custom plates	% on entry colorstop is custom	% c m y k (name) tint 2|3 midPoint rampPoint	/endCapSepBc	{		/white? false store		pop pop		dup 0 eq		{			pop			/white? 1 index 1 eq store			setgray		}		{			1 eq			{				setcmykcolor			}			{				setCustomColor			} ifelse		} ifelse%% new	(bh 11/22/93)		currentcmykcolor anyColor?		endC? or		blend? and		{			bFill		}		{			handleOP		} ifelse	} bd	/Bc	{		% *** (\nin custom Bc nColors = ) print nColors ==			% *** (blend? = ) print blend? ==		gsave		setBSpace		nColors 1 gt		{			% start cap			% *** (entry sep start cap\n) print			blend? startC? and			{				bFill			}			{				handleOP			} ifelse% *** (exit sep start cap\n) print			}		{			endCapSepBc		} ifelse		grestore		newpath% ***	(exit Bc\n) print	} bd	/linealBm	{		/nColors dup load 1 sub store% *** (\nin custom sep linealBm :  nColors = ) print nColors ==		% *** linear blend color type selection here		% *** (blend? = ) print blend? ==		newpath		gsave		setBSpace		blend?		{			cData type /stringtype eq			{				linImg			}			{				bFill			} ifelse		}		{			handleOP		} ifelse		grestore		nColors 1 gt		{			% *** (calling getRData in /linealBm\n) print			getRData		} if% *** (exit linealBm\n)print	} bd% used only in custom get data	/discardCMY	{		counttomark 4 add -3 roll pop pop pop	} bd	/testTopCC	{		6 copy ccThrough?	} bd	/getCRamp	{		% *** (in getCRamp\n) print			% *** (getting data for blend on customcolor plate\n) print		{			ccDataProcs colorType 2 sub get exec		} stopped pop		% we might have no data in the black channel		% but be forcing the blend, so update 'cDataLen if needed		blend? cDataLen 0 eq and		{			/cDataLen bDataLen store		} if		% *** (return from custom data selection\n) print		% *** (blend? = ) print blend? ==		% *** (fCMYK? = ) print fCMYK? ==		% on return		% if blend? = false :  no blend, knock out based on overprint		% if blend? = true		% if colorType = 1 and fCMYK? = true		% we have a blend from 0 > custom or 0 0 0 0 > custom		% or custom > 0 or custom > 0 0 0 0 		% the initial color has been set		% and we need to image the blend on this plate using the cmyk strings		% which is all the data we have anyhow		% if colorType = 2				% initial color set		% cData has tint1Data : do the blend		% if colorType = 3				% initial color set or next color set		% cData has either tint1Data or tint2Data : do the blend				} bd	/ccGetRData	{		% *** (enter ccGetRData\n) print		% assume no forced call to setcmykcolor		/fCMYK? false store		% assume we do no caps		/startC? false store		/endC? false store% new test for setting blend? flag : set it to false only if %	colorType is 0 (gray) or colorType is 1 (cmyk) (bh 3/22/94)		colorType 2 lt		{			/blend? false def		} if		blend?		{			% *** (getting custom data\n) print			getCRamp% *** (start cap ? ) print startC? ==% *** (end cap ? ) print endC? ==		}		{			% *** (skipping getting custom data because of blend type\n) print			setCStop		} ifelse		blend?		{			/blend? cData 1 ne store			blend?			{				cData dup type /stringtype ne				{					1 exch sub /cData xs 0				} if				pop			} if		} if% *** (exit ccGetRData\n) print		} def	/ccDataProcs	[% customcolor tint blend on a custom plate	/eCCBlend load% customcolor|black to customcolor|black blend on a customcolor plate	{		%		(in ccDataProc #1) ==		% if it's a radial, swap tint data		cBType 1 eq		{			tint1Data tint2Data			/tint1Data xs			/tint2Data xs		} if		0 eq		{			% a gray color spec			%			(first color is a gray value) ==			/blend? false store			pop		}		{			% *** (customcolor to customcolor blend on a customcolor plate\n) print			% c m y k (name2) tint 2 midPoint rampPoint mark c m y k (name1) tint			% we do the blend if the current or next custom color			% goes through on the current plate			% test the first color if			mark 7 1 roll			% we do the blend using tint1Data if a 100% push of the current custom			% color results in black color only on the current plate			testTopCC			{				% *** (first color goes through\n) print													% we do the start cap on this plate if the first tint is non-zero				% c m y k (name2) tint 2 midPoint rampPoint mark c m y k (name1) tint				/blend? 1 index 1 ne store				/startC? blend? store				/endC? false store				blend? not				{					cleartomark stop				} if				% leave the end cap false in this case				% *** (customcolor ramp using tint1Data\n) print																			% check tint1Data for ramp contents				/cData tint1Data store				setCDataLen				setCustomColor				pop				stop			} if			cleartomark		} ifelse%		(first color does not go through\n) print											% if the first custom color doesn't go through we		% must now consider the next one%		2 index (colortype= ) print ==		% get colortype of next stop		2 index 0 eq		{			%			(2nd stop is a gray value) ==			/blend? false store		}		{			% otherwise a custom color spec (colortype==3)			%			(2nd stop is a custom color) ==			% c m y k (name) tint 3 midPoint rampPoint			mark 6			{				9 index			} repeat			% we do the blend using tint2Data if a 100% push of the next custom			% color results in color on the current plate			testTopCC dup /blend? xs% dup { (second color goes through\n) print } { (second color does not go through\n) print } ifelse			{				% *** (customcolor ramp using tint2Data\n) print				% check tint2Data for ramp contents				% c m y k (name) tint 3 midPoint rampPoint mark c m y k (name) tint				% we do the end cap on this plate if the final tint is non-zero				/blend? 1 index 1 ne store				/endC? blend? store				/startC? false store				blend? not				{					cleartomark stop				} if				% leave the start cap false in this case				% note we do not set the customcolor here !				/cData tint2Data store				setCDataLen			} if			cleartomark		} ifelse	} bind	] def	/ccGetRData} if% define the plate specific data fetch and analyze procedure% *** (get data procedure = ) print dup ==load Adobe_blend_AI5_vars /getData 3 -1 roll put/setCDataLen{	/cDataLen 0 cData dup type /stringtype eq	{		length exch	} if	pop store} bd% isCMYKSep? { scratchSave restore } if/initSpotData	% dict initSpotData -{	begin		/name null def		/tintImage null def		/tintValue null def		/spot_C  null def		/spot_M  null def		/spot_Y  null def		/spot_K  null def	end} bd/getRData{%	(in getRData\n) print	/colorType gMark store	_compositeSpotDevice 0 ne	{		spotDict begin			spot1 initSpotData			spot2 initSpotData		end		/spotColor? colorType 2 eq colorType 3 eq or def	} 	{		/spotColor? false store	} ifelse	/blend? true store	0 0 0 0 setcmykcolor	100 div /rampPoint xs% (between 13 and 87%) 	100 div /midPoint xs	% *** get the end point now	%	we're looking at the NEXT color stop (starting w/ rampPoint)	% colorSpec colorStyle midPoint rampPoint 0 0	% colorSpec colorStyle midPoint rampPoint c m y k 1	% colorSpec colorStyle midPoint rampPoint c m y k (name) tint 3		dup 0 eq	{		2	}	{		dup 1 eq		{			5		}		{			% otherwise is 3			_compositeSpotDevice 0 ne			{				spotDict begin					spot1 begin						/name 3 index def						/spot_K 4 index def						/spot_Y 5 index def						/spot_M 6 index def						/spot_C 7 index def					end				end			} if			7		} ifelse	} ifelse	/tmp exch def	tmp index 100 div /endPoint xs	_compositeSpotDevice 0 ne	{		tmp 2 add index 3 eq		{			/tmp tmp 4 add def			tmp index dup 			spotDict begin				spot1/name get ne				{					spot2 begin						/name exch def						/spot_K tmp 2 add index def						/spot_Y tmp 3 add index def						/spot_M tmp 4 add index def						/spot_C tmp 5 add index def					end				}				{					pop				} ifelse			end		} if	} if	/color? colorType 0 gt store		colorType 3 eq	{		/tint2Data gMark store	} if		colorType 2 ge	{		/tint1Data gMark store	} if	_compositeSpotDevice 0 ne	{		spotDict begin					colorType 2 ge			{				colorType 3 eq				{					spot2 begin						/tintImage cBType 0 eq {tint2Data} {tint1Data} ifelse def						name null eq {/name /Black def} if					end				} if				spot1 begin					/tintImage cBType 0 eq colorType 2 eq or {tint1Data} {tint2Data} ifelse def					colorType 2 eq 					{						% If the spot1 name is still null, then we need to grab it						% from spot2 dict and set the spot2 dict name to null.						% (this happens when the first color stop is white)						name null eq 						{							/name spot2/name get def							spot2/name null put						} if					}					{ % else colorType is 3						name null eq {/name /Black def} if					} ifelse				end			} if		end	} if		/cData gMark store	setCDataLen	colorType 0 gt	{		counttomark 4 add -3 roll		/yeData xs		/mgData xs		/cyData xs	} if	% *** can quit here if data not well-formed	% at this point all the data is off the stack	blend?	{		/bDataLen		cDataLen dup 0 eq color? and		{			[			cyData mgData yeData			]			{				dup type /stringtype eq				{					length exch pop exit				} if				pop			} forall		} if		store		bDataLen 0 eq		{			/bDataLen 1 store		} if		getData		blend?		{			composite? cDataLen 0 eq and			{				/cDataLen bDataLen store			} if		} if	}	{		% *** erase the color stop if we're quitting early		setCStop	} ifelse} bd/Bg{	% set to initial white	0 0 0 0 setcmykcolor	6	{		pop	} repeat	/blendLength xs	pop pop pop% *** (\n\nin Bg : ) print dup ==	/cBName xs	/bRender xs	bRender 2 ne	{		% if we're not on a composite plate,		% make sure the overprint flag is updated		% for the blend as a whole		composite? not		{			% make sure the overprint flag is updated			_of setoverprint		} if		% we always clip to the path		_eo {eoclip} {clip} ifelse		_bn cBName 2 copy known		{			get			mark exch aload pop			/cBType xs			% *** (nColors = ) print dup ==			/nColors xs			mark exch aload pop			0 0		} if		pop pop		getRData		cBType 0 eq		{			% *** /doBlend is now defined in /linealBm for lineals			% *** (lineal blend\n) print			/linealBm		}		{			bHi?			{				/pTState? nColors 2 gt store			} if			/doBlend /rdBlend load store			/rdBm		} ifelse	}	{		inLine? not		{			mark mark		} if		/Bc dup		{			cleartomark mark		} bd		/nullProc	} ifelse	load /Bm xs% *** (exit Bg\n) print} bd/linImgnoImg{	{		newpath doRctBlend	}}{	{		% cData holds a string		% *** (entering linImg\n) print				/doBlend		color? composite? and		{			/bCImg		}		{			/bwImage		} ifelse% *** (blend procedure : ) print dup ==		load		store			0 0 moveto		% added composite condition for rectangle tiling (bh 3/21/94)		tRectOK? composite? and		{			% *** new test for not skewed and modulo 90 degree rotation			% *** wrapped in a stopped to intercept degenerate matrix errors			{				mark				0 1 dtransform atan cvi 90 mod 0 eq				1 0 dtransform atan cvi 90 mod 0 eq			} stopped			{				% error in atan				cleartomark			}			{				and exch pop				{					newpath					% *** (tile with rect blend\n) print					doRctBlend				}				{					doBlend				} ifelse			} ifelse		}		{			doBlend		} ifelse	} } ifelse% *** (exit linImg\n) printbd/doRctBlend{	gsave	/sInc 1 store	/nSamples bDataLen store	/bInc 1 bDataLen div store	/ubAxis 1 0 dtransform dUserSpace idtransform dup mul exch dup mul add sqrt store	/pChange ubAxis 0 eq	{		0	}	{		bDataLen ubAxis div	} ifelse	store	pChange .5 gt noImg not and dup /optimize? xs	{		% *** round result stored in nSamples		% *** must be integer since we use it to control repeat loop		% *** keep a minimum of 2 samples : if nSamples was 1		% *** we'd get a divide by zero error in calculating sInc		% *** 0 samples would make no sense		/nSamples ubAxis 2 div round cvi dup 1 le		{			pop 2		} if		store		/bInc 1 nSamples div store		/sInc bDataLen 1 sub nSamples 1 sub div store	} if	% *** push #0 for initial sampling index	0	nSamples	[	% *** copy the current sampling  index	/dup cvx	optimize?	{		/round cvx /cvi cvx	} if	/ndx /exch cvx /store cvx	bCFun%	Don't use /rectfill if _compositeSpotDevice is enabled 	/rectfill where dup	{		exch pop _compositeSpotDevice 1 ne and	} if	{		0 0 bInc 1 /rectfill cvx		}	{		0 0 /moveto cvx		bInc 0 /lineto cvx		bInc 1 /lineto cvx		0 1 /lineto cvx		/closepath cvx		/_fill_ cvx	} ifelse	bInc 0 /translate cvx	% *** add sampling increment to curent ndx value	sInc /add cvx	] cvx	bind	repeat	% *** pop off sampling index	pop	% turn off ncustomcolor mode	spotColor? {nsetcustomcolorend} if		grestore} bd/rdPrep{	/nSamples bDataLen dup 0 eq	{		pop 1	} if	store	/sInc -1 store	/bAxis rampPoint endPoint sub store	% *** made bInc negative here for consistency	/bInc bAxis bDataLen div neg store	/optimize? false store	tRectOK?	{		/ubAxis		bAxis 0 dtransform dUserSpace idtransform dup mul exch dup mul add sqrt		0 bAxis dtransform dUserSpace idtransform dup mul exch dup mul add sqrt		2 copy lt		{			exch		} if		pop store		/pChange ubAxis 0 eq		{			0		}		{			bDataLen ubAxis div		} ifelse		store		% added noImg condition so that radials always print in full res 		% w/ compatible gradients setting turned ON (bh 9/2/94)		pChange .5 gt noImg not and dup /optimize? xs		{			% *** round result stored in nSamples			% *** must be integer since we use it to control repeat loop			% *** keep a minimum of 2 samples : if nSamples was 1			% *** we'd get a divide by zero error in calculating sInc			% *** 0 samples would make no sense			/nSamples ubAxis 2 div round cvi dup 1 le			{				pop 2			} if			store			% *** removed adding 1 to nSamples here			/bInc bAxis nSamples div neg store			/sInc bDataLen 1 sub nSamples 1 sub div neg store		} if	} if	bHi?	{		/xBCInc xHi bAxis mul nSamples div store		/yBCInc yHi bAxis mul nSamples div store	} if} bd/rdBlend{	newpath	gsave	rdPrep	% push rampPoint for initial radius	rampPoint	% push bDataLen for initial sampling index	bDataLen 1 sub	nSamples	[	% *** duplicate working sampling index	/dup cvx	optimize?	{		/round cvx /cvi cvx	} if	/ndx /exch cvx /store cvx	bCFun	% *** changed to reflect extra variable on stack	0 0 3 /index cvx 0 360 /arc cvx /_fill_ cvx	% *** decrement radius	/exch cvx bInc /add cvx /exch cvx	% *** decrement sampling index	sInc /add cvx	bHi?	{		xBCInc yBCInc /translate cvx	} if	] cvx	bind	repeat	% *** pop off rampPoint and sampling index	pop pop	% turn off ncustomcolor mode	spotColor? {nsetcustomcolorend} if	grestore	pTState?	{		xHi bAxis mul yHi bAxis mul translate	} if} bd/Bh{	pop pop	% assume no hilite	/pTState? false store	2 copy 0 ne exch 0 ne or dup /bHi? xs	{		/yHi xs		/xHi xs		0 0	} if	pop pop} bd/BD{	inLine? not	{		] nColors cBType		] _bn cBName 3 -1 roll put	end} if} bd/Bn{1 add dictdup nullString null put/_bn xs} bd/Bd{Adobe_blend_AI5_vars begin	3 -1 roll dup nullString eq dup	{		setSSave	} if	/inLine? exch def	/cBName exch def	/nColors exch def	/cBType exch def} bd/Bb{	sSave null eq	{		Adobe_blend_AI5_vars begin		setSSave	} if	% enforce fill overprint semantics for white in gradients (bh 3/26/94)	composite?	{		/_fill /fill load store	}	{		/__fill /fill load store			/_fill			{				_of true eq				{					currentgray 1 ne					{						__fill					} if				}				{					__fill				} ifelse			} def	} ifelse	/fill	{	} def	} bd	/BB	{	/cBType xs	cleartomark cleartomark	cBType dup	bRender	% *** fix future problems before they fix you !	sSave dup type /savetype eq	{		restore 0	} if	pop	currentdict Adobe_blend_AI5_vars eq	{		end	} if	2 ne exch 0 gt and	{		2 eq		{			s		}		{			S		} ifelse	}	{		% must clear the path if it's a fill only		pop newpath	} ifelse} bdcurrentdict readonly popendenddefaultpacking setpacking%%EndResource% ------------------------------------------------------%%BeginProcSet: Adobe_ColorImage_AI6 1.0 0% ColorImage Emulation and Separation Code for Grayscale, RGB and CMYK images% Version 1.0 12/25/95% Copyright (C) 1995-96% Adobe Systems Incorporated% All Rights Reserved% ------------------------------------------------------userdict /Adobe_ColorImage_AI6 known not{	userdict /Adobe_ColorImage_AI6 17 dict put } ifuserdict /Adobe_ColorImage_AI6 get begin% ------------------------------------------------------% Routine Overview% %	String Iterators%		WalkRGBString (given a single source string, convert each pixel to cmyk and call a proc)%		WalkCMYKString (given a single source string, get the components and call a proc)% %	Level1 Emulator Routines%		StuffRGBIntoGrayString%		RGBToGrayImageProc%		StuffCMYKIntoGrayString %		CMYKToGrayImageProc %		ColorImageCompositeEmulator % %	ColorImage CMYK Separation Hacks (For [Applications] that only support planar images)%		CMYKToSeparatedCMYKImageProc% %	ColorImage and Utility Routines.%		FourEqual%		TestPlateIndex%		colorimage% % ------------------------------------------------------	/initialize{ 	Adobe_ColorImage_AI6 begin	Adobe_ColorImage_AI6	{		dup type /arraytype eq		{			dup xcheck			{				bind			} if		} if		pop pop	} forall} def/terminate { end } defcurrentdict /Adobe_ColorImage_AI6_Vars known not{	/Adobe_ColorImage_AI6_Vars 14 dict def} ifAdobe_ColorImage_AI6_Vars begin	/channelcount 0 def	/sourcecount 0 def	/sourcearray 4 array def	/plateindex -1 def	/XIMask 0 def	/XIBinary 0 def	/XIChannelCount 0 def	/XIBitsPerPixel 0 def	/XIImageHeight 0 def	/XIImageWidth 0 def	/XIImageMatrix null def	/XIBuffer null def	/XIDataProc null defend/WalkRGBString null def/WalkCMYKString null def/StuffRGBIntoGrayString null def/RGBToGrayImageProc null def/StuffCMYKIntoGrayString null def/CMYKToGrayImageProc null def/ColorImageCompositeEmulator null def/SeparateCMYKImageProc null def/FourEqual null def/TestPlateIndex null def% define _colorimage if it doesn't already existcurrentdict /_colorimage known not{	/colorimage where	{		% sourcedictionary (systemdict or a separation proc redefinition)		/colorimage get /_colorimage exch def	}	{		/_colorimage null def	} ifelse} if/_currenttransfer systemdict /currenttransfer get def/colorimage null def/XI null def% ------------------------------------------------------% rgb proc out --WalkRGBString--% ------------------------------------------------------/WalkRGBString{	% rgb proc out	0 3 index	% rgb proc out outindex rgb	dup length 1 sub 0 3 3 -1 roll	{		% rgb proc out outindex rgb index		3 getinterval { } forall		% call the stuff proc		% rgb proc out outindex r g b		5 index exec		% push rgb for the next loop iteration		% rgb proc out outindex		3 index		% rgb proc out outindex rgb	} for		% clean up the stack	% rgb proc out outindex rgb	 5 { pop } repeat} def% ------------------------------------------------------% cmyk proc gray --WalkCMYKString--% ------------------------------------------------------/WalkCMYKString{	% cmyk proc gray	0 3 index	% cmyk proc gray grayindex cmyk	dup length 1 sub 0 4 3 -1 roll	{		% cmyk proc gray grayindex cmyk index		4 getinterval { } forall				% cmyk proc gray grayindex c m y k		6 index exec				% cmyk proc gray grayindex		3 index				% cmyk proc gray grayindex cmyk	} for		% clean up the stack	% cmyk proc gray grayindex cmyk	5 { pop } repeat	} def% ------------------------------------------------------% gray grayindex r g b --StuffRGBIntoGrayString-- gray grayindex% ------------------------------------------------------/StuffRGBIntoGrayString{	% gray grayindex r g b	.11 mul exch		% gray grayindex r bk g	.59 mul add exch		% gray grayindex bkgk r	.3 mul add		% gray grayindex k	cvi 3 copy put		% gray grayindex k	pop 1 add} def% ------------------------------------------------------% --RGBToGrayImageProc-- string% ------------------------------------------------------/RGBToGrayImageProc{		Adobe_ColorImage_AI6_Vars begin			% call the source proc to get the chunky rgb string		sourcearray 0 get exec		% make a grayscale string of the same pixel count (ouch, pull me out of this loop)		% rgb		dup length 3 idiv string		% roll off a copy of the gray string		% rgb gray		dup 3 1 roll 				% push the stuff proc that we want called by WalkRGBString		% gray rgb gray		/StuffRGBIntoGrayString load exch		% call the rgb conversion iterator		% gray rgb proc gray		WalkRGBString		% return the gray string		% gray		end} def% ------------------------------------------------------% gray grayindex c m y k --StuffCMYKIntoGrayString-- gray grayindex% ------------------------------------------------------/StuffCMYKIntoGrayString{	% gray grayindex c m y k	exch .11 mul add		% gray grayindex c m yk	exch .59 mul add		% gray grayindex c mkyk	exch .3 mul add		% pin k to 255	% gray gray index k	dup 255 gt { pop 255 } if		% gray grayindex k	255 exch sub cvi 3 copy put		% gray grayindex k	pop 1 add} def% ------------------------------------------------------% --CMYKToGrayImageProc-- string% ------------------------------------------------------/CMYKToGrayImageProc{		Adobe_ColorImage_AI6_Vars begin		% call the source proc to get the chunky cmyk string		sourcearray 0 get exec		% make a grayscale string of the same pixel count (ouch, pull me out of this loop)		% cmyk		dup length 4 idiv string		% roll off a copy of the gray string		% cmyk gray		dup 3 1 roll 				% push the stuff proc that we want called by WalkCMYKString		% gray cmyk gray		/StuffCMYKIntoGrayString load exch		% call the cmyk iterator		% gray cmyk proc gray		WalkCMYKString		% return the gray string		% gray	end} def% ------------------------------------------------------% width height bitsperpixel matrix firstsource...lastsource multiplesources channelcount --ColorImageCompositeEmulator--% ------------------------------------------------------/ColorImageCompositeEmulator{	% Channelcount is already saved in Adobe_ColorImage_AI6_Vars. Our data is always in chunky form so punt if someone	% calls colorimage on a level 1 device with planar data.	% channelcount and multiplesources are already saved in Adobe_ColorImage_AI6_Vars. The image operator isn't going to use them.	pop true eq	{		% pop off the parameters and return		Adobe_ColorImage_AI6_Vars /sourcecount get 5 add { pop } repeat	}	{		Adobe_ColorImage_AI6_Vars /channelcount get 1 ne		{			Adobe_ColorImage_AI6_Vars begin				% save off the original chunky source function				sourcearray 0 3 -1 roll put							% push the appropriate cover proc				channelcount 3 eq 				{ 					/RGBToGrayImageProc 				}				{ 					/CMYKToGrayImageProc				} ifelse				load			end		} if		image	} ifelse} def% ------------------------------------------------------% --SeparateCMYKImageProc-- string% ------------------------------------------------------/SeparateCMYKImageProc{		Adobe_ColorImage_AI6_Vars begin		sourcecount 0 ne		{			% planar case: call the source proc for the current plate and return its result			sourcearray plateindex get exec		}		{						% call the source proc to get the chunky cmyk string			sourcearray 0 get exec						% make a grayscale string of the same pixel count (ouch, pull me out of this loop)			% cmyk			dup length 4 idiv string						% cmyk			0 2 index						% cmyk gray grayindex cmyk			plateindex 4 2 index length 1 sub			{				% cmyk gray grayindex cmyk channelindex				get 255 exch sub								% cmyk gray grayindex grayvalue				3 copy put pop 1 add								% cmyk gray grayindex				2 index			} for			% return the gray string			% cmyk gray grayindex cmyk			pop pop exch pop		} ifelse	end} def	% ------------------------------------------------------% s1 s2 s3 s4 c1 c2 c3 c4 --FourEqual--% ------------------------------------------------------/FourEqual{	% s1 s2 s3 s4 c1 c2 c3 c4	4 index ne	{		pop pop pop false	}	{		% s1 s2 s3 s4 c1 c2 c3		4 index ne		{			pop pop false		}		{			% s1 s2 s3 s4 c1 c2			4 index ne			{				pop false			}			{				% s1 s2 s3 s4 c1				4 index eq			} ifelse		} ifelse	} ifelse} def% ------------------------------------------------------%  --TestPlateIndex-- plateindex% ------------------------------------------------------/TestPlateIndex{	Adobe_ColorImage_AI6_Vars begin		% assume we're not separating		/plateindex -1 def		/setcmykcolor where		{			pop			gsave			1 0 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub			0 1 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub			0 0 1 0 setcmykcolor systemdict /currentgray get exec 1 exch sub			0 0 0 1 setcmykcolor systemdict /currentgray get exec 1 exch sub			grestore			% cyan plate?			1 0 0 0 FourEqual 			{ 				/plateindex 0 def			}			{				% magenta plate?				0 1 0 0 FourEqual				{ 					/plateindex 1 def				}				{					% yellow plate?					0 0 1 0 FourEqual					{						/plateindex 2 def					}					{						% black plate						0 0 0 1 FourEqual						{ 							/plateindex 3 def						}						{							0 0 0 0 FourEqual							{								/plateindex 5 def							} if						} ifelse					} ifelse				} ifelse			} ifelse			pop pop pop pop		} if		plateindex	end} def% ------------------------------------------------------% width height bitsperpixel matrix firstsource...lastsource multiplesources channelcount --colorimage--% ------------------------------------------------------/colorimage{	Adobe_ColorImage_AI6_Vars begin		/channelcount 1 index def		/sourcecount 2 index 1 eq { channelcount 1 sub } { 0 } ifelse def		% setup for following if statement		4 sourcecount add index dup 		8 eq exch 1 eq or not	end		% is this not 1 or 8 bit?	{		% Call the original proc if the image is at a weird bit depth. This will display a composite if we're separating, but too bad.		/_colorimage load null ne		{			% call the original (they probably punt if we're separating)			_colorimage		}		{			% pop off the parameters and return			Adobe_ColorImage_AI6_Vars /sourcecount get			7 add { pop } repeat		} ifelse	}	{		% Call the saved colorimage operator if this an rgb, we're printing a composite or we're separating		% an image to a custom plate. The last case assumes that the separation procs surrounding us		% take care of punching out		dup 3 eq		TestPlateIndex		dup -1 eq exch 5 eq or or		{			% Call the colorimage emulator if we're printing to a level 1 device			/_colorimage load null eq			{				ColorImageCompositeEmulator			}			{				% call image if this is a grayscale so that Quark doesn't die on custom plates				dup 1 eq				{					pop pop image				}				{					% draw to the null device if we're on a custom plate					Adobe_ColorImage_AI6_Vars /plateindex get 5 eq					{						gsave												% stolen from PhotoShop						0 _currenttransfer exec						1 _currenttransfer exec						eq						{ 0 _currenttransfer exec 0.5 lt }						{ 0 _currenttransfer exec 1 _currenttransfer exec gt } ifelse												% push the appropriate transfer proc (first case is negative						% second case is positive) and call settransfer						{ { pop 0 } } { { pop 1 } } ifelse						systemdict /settransfer get exec					} if										_colorimage										% restore from the null device if necessary					Adobe_ColorImage_AI6_Vars /plateindex get 5 eq					{						grestore					} if				} ifelse			} ifelse		}		{			% Are we separating a grayscale image?			dup 1 eq			{				% let the surrounding separation procset handle the separation				pop pop				image			}			{				% pop channelcount and multiplesources since they're not used by the image operator				pop pop				% Prepare to call the image operator with a cover proc				Adobe_ColorImage_AI6_Vars begin					% save off the source procs for our cover proc					% width height bitsperpixel matrix firstsource...lastsource					sourcecount -1 0					{									% width height bitsperpixel matrix firstsource...lastsource index						exch sourcearray 3 1 roll put					} for					/SeparateCMYKImageProc load				end				% bypass the separation procset since some applications don't handle chunky and the				% old separator doesn't handle colorimage				systemdict /image get exec			} ifelse		} ifelse	} ifelse} def% ------------------------------------------------------% --XI--% ------------------------------------------------------/XI{	Adobe_ColorImage_AI6_Vars begin		gsave		/XIMask exch 0 ne def		/XIBinary exch 0 ne def		pop		pop		/XIChannelCount exch def		/XIBitsPerPixel exch def		/XIImageHeight exch def		/XIImageWidth exch def		pop pop pop pop		/XIImageMatrix exch def				XIBitsPerPixel 1 eq		{			XIImageWidth 8 div ceiling cvi		}		{			XIImageWidth XIChannelCount mul		} ifelse		/XIBuffer exch string def				XIBinary		{			/XIDataProc { currentfile XIBuffer readstring pop } def			% skip the %BeginBinary comment			currentfile 128 string readline pop pop		}		{			/XIDataProc { currentfile XIBuffer readhexstring pop } def		} ifelse				0 0 moveto		XIImageMatrix concat		XIImageWidth XIImageHeight scale				XIMask		{			XIImageWidth XIImageHeight			false			[ XIImageWidth 0 0 XIImageHeight neg 0 0 ]			/XIDataProc load						% synch the PostScript fill with Illustrator's notion of the current fill			/_lp /null ddef			_fc			/_lp /imagemask ddef						imagemask		}		{			XIImageWidth XIImageHeight			XIBitsPerPixel			[ XIImageWidth 0 0 XIImageHeight neg 0 0 ]			/XIDataProc load						% call image if passed grayscale or bitmap data. Some applications			% die if colorimage is called with gray data.			XIChannelCount 1 eq			{				% Some applications refuse to separate a grayscale image to the black plate if				% the currentgray is white. Hack around.								gsave				0 setgray								image								grestore			}			{				false				XIChannelCount				colorimage			} ifelse		} ifelse		grestore	end} def	end%%EndProcSet% ------------------------------------------------------%%BeginResource: procset Adobe_Illustrator_AI5 1.1 0%%Title: (Adobe Illustrator (R) Version 5.0 Full Prolog)%%Version: 1.1 0%%CreationDate: (3/7/1994) ()%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)% ------------------------------------------------------currentpacking true setpacking% 71 vars, but leave slack of 10 entries for custom Postscript fragmentsuserdict /Adobe_Illustrator_AI5_vars 81 dict dup beginput% paint operands/_eo false def/_lp /none def/_pf{} def	% paint fill/_ps{} def	% paint stroke/_psf{} def	% paint string fill/_pss{} def	% paint string stroke/_pjsf{} def	% paint justified string fill/_pjss{} def	% paint justified string stroke/_pola 0 def/_doClip 0 def% paint operators/cf currentflat def	% - cf flatness% typography operands/_tm matrix def/_renderStart[/e0 /r0 /a0 /o0 /e1 /r1 /a1 /i0] def/_renderEnd[null null null null /i1 /i1 /i1 /i1] def/_render -1 def/_rise 0 def/_ax 0 def	% x character spacing	(_ax, _ay, _cx, _cy follows awidthshow naming convention)/_ay 0 def	% y character spacing/_cx 0 def	% x word spacing/_cy 0 def	% y word spacing/_leading[0 0] def/_ctm matrix def/_mtx matrix def/_sp 16#020 def/_hyphen (-) def/_fScl 0 def/_cnt 0 def/_hs 1 def/_nativeEncoding 0 def/_useNativeEncoding 0 def/_tempEncode 0 def/_pntr 0 def/_tDict 2 dict def/_wv 0 def% typography operators/Tx{} def/Tj{} def% compound path operators/CRender{} def% printing/_AI3_savepage{} def% color operands/_gf null def/_cf 4 array def/_if null def/_of false def/_fc{} def/_gs null def/_cs 4 array def/_is null def/_os false def/_sc{} def% pattern operands/_pd 1 dict def/_ed 15 dict def/_pm matrix def/_fm null def/_fd null def/_fdd null def/_sm null def/_sd null def/_sdd null def/_i null def% discard variables (12 total)/discardSave null def	% holds save used in discard loop/buffer 256 string def	% line buffer string : assume 256 chars/line/beginString null def	% begin delimiter/endString null def	% end delimiter/endStringLength null def	% holds buffer size for reading by byte technique/layerCnt 1 def	% internal variables for discard loop/layerCount 1 def/perCent (%) 0 get def/perCentSeen? false def/newBuff null def/newBuffButFirst null def/newBuffLast null def% variable for doing clipping without rendering/clipForward? false def% end the vars dictionaryend% =========================================userdict /Adobe_Illustrator_AI5 known not {	userdict /Adobe_Illustrator_AI5 91 dict put} ifuserdict /Adobe_Illustrator_AI5 get begin% initialization/initialize	% - initialize -{	% pushing main on the stack	Adobe_Illustrator_AI5 dup begin	% push the vars dictionary	Adobe_Illustrator_AI5_vars begin	% at this point the main and vars dictionaries	% are in the state we wish them to be	% on exit from the initialize call	% bind the procedures in the discard dictionary	discardDict	{		bind pop pop	} forall	% begin the nc dictionary	dup /nc get begin	% bind the procs in main	{		% added a test for type = operatortype so procedures like Ln can be defined as an alias for 'pop		dup xcheck 1 index type /operatortype ne and		{			bind		} if		pop pop	} forall	% turn off 'nc	end	newpath	% on exit we have main and vars on top of dict stack} def/terminate	% - terminate -{	end	end} def% definition operators/_	% - _ nullnull def/ddef	% key value ddef -{	Adobe_Illustrator_AI5_vars 3 1 roll put} def/xput	% key value literal xput -{	dup load dup length exch maxlength eq	{		dup dup load dup		length 2 mul dict copy def	} if	load begin	def	end} def/npop	% integer npop -{	{		pop	} repeat} def% marking operators/sw	% ax ay string sw x y{	dup length exch stringwidth	exch 5 -1 roll 3 index mul add	4 1 roll 3 1 roll mul add} def/swj	% cx cy fillchar ax ay string swj x y{	dup 4 1 roll	dup length exch stringwidth	exch 5 -1 roll 3 index mul add	4 1 roll 3 1 roll mul add	6 2 roll /_cnt 0 ddef	{		1 index eq		{			/_cnt _cnt 1 add ddef		} if	} forall	pop	exch _cnt mul exch _cnt mul 2 index add 4 1 roll 2 index add 4 1 roll pop pop} def/ss	% ax ay string matrix ss -{	4 1 roll	{		% matrix ax ay char 0 0 {proc} -		2 npop		(0) exch 2 copy 0 exch put pop		gsave		false charpath currentpoint		4 index setmatrix		stroke		grestore		moveto		2 copy rmoveto	} exch cshow	3 npop} def/jss	% cx cy fillchar ax ay string matrix jss -{	4 1 roll	{		% cx cy fillchar matrix ax ay char 0 0 {proc} -   		2 npop		(0) exch 2 copy 0 exch put		gsave		_sp eq		{			exch 6 index 6 index 6 index 5 -1 roll widthshow			currentpoint		}		{			false charpath currentpoint			4 index setmatrix stroke		} ifelse		grestore		moveto		2 copy rmoveto	} exch cshow	6 npop} def% path operators/sp	% ax ay string sp -{	{		2 npop (0) exch		2 copy 0 exch put pop		false charpath		2 copy rmoveto	} exch cshow	2 npop} def/jsp	% cx cy fillchar ax ay string jsp -{	{		% cx cy fillchar ax ay char 0 0 {proc} -		2 npop		(0) exch 2 copy 0 exch put		_sp eq		{			exch 5 index 5 index 5 index 5 -1 roll widthshow		}		{			false charpath		} ifelse		2 copy rmoveto	} exch cshow	5 npop} def% path construction operators/pl	% x y pl x y{	transform	0.25 sub round 0.25 add exch	0.25 sub round 0.25 add exch	itransform} def/setstrokeadjust where{	pop true setstrokeadjust	/c	% x1 y1 x2 y2 x3 y3 c -	{		curveto	} def	/C	/c load def	/v	% x2 y2 x3 y3 v -	{		currentpoint 6 2 roll curveto	} def	/V	/v load def	/y	% x1 y1 x2 y2 y -	{		2 copy curveto	} def	/Y	/y load def	/l	% x y l -	{		lineto	} def	/L	/l load def	/m	% x y m -	{		moveto	} def}{	% else	/c	{		pl curveto	} def	/C	/c load def	/v	{		currentpoint 6 2 roll pl curveto	} def	/V	/v load def	/y	{		pl 2 copy curveto	} def	/Y	/y load def	/l	{		pl lineto	} def	/L	/l load def	/m	{		pl moveto	} def} ifelse% graphic state operators/d	% array phase d -{	setdash} def/cf{} def	% - cf flatness/i	% flatness i -{	dup 0 eq	{		pop cf	} if	setflat} def/j	% linejoin j -{	setlinejoin} def/J	% linecap J -{	setlinecap} def/M	% miterlimit M -{	setmiterlimit} def/w	% linewidth w -{	setlinewidth} def% path painting operators/XR	% flag XR -{	0 ne	/_eo exch ddef} def/H	% - H -{} def/h	% - h -{	closepath} def/N	% - N -{	_pola 0 eq	{		_doClip 1 eq		{			_eo {eoclip} {clip} ifelse /_doClip 0 ddef		} if		newpath	}	{		/CRender		{			N		} ddef	} ifelse} def/n	% - n -{	N} def/F	% - F -{	_pola 0 eq	{		_doClip 1 eq		{			gsave _pf grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _fc			/_doClip 0 ddef		}		{			_pf		} ifelse	}	{		/CRender		{			F		} ddef	} ifelse} def/f	% - f -{	closepath	F} def/S	% - S -{	_pola 0 eq	{		_doClip 1 eq		{			gsave _ps grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc			/_doClip 0 ddef		}		{			_ps		} ifelse	}	{		/CRender		{			S		} ddef	} ifelse} def/s	% - s -{	closepath	S} def/B	% - B -{	_pola 0 eq	{		_doClip 1 eq	% F clears _doClip		gsave F grestore		{			gsave S grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc			/_doClip 0 ddef		}		{			S		} ifelse	}	{		/CRender		{			B		} ddef	} ifelse} def/b	% - b -{	closepath	B} def/W	% - W -{	/_doClip 1 ddef} def/*	% - [string] * -{	count 0 ne	{		dup type /stringtype eq		{			pop		} if	} if	% used to call newpath only if _polo was 0; now newpath is called unconditionally (bh 3/24/94)	newpath} def% group operators/u	% - u -{} def/U	% - U -{} def/q	% - q -{	_pola 0 eq	{		gsave	} if} def/Q	% - Q -{	_pola 0 eq	{		grestore	} if} def/*u	% - *u -{	_pola 1 add /_pola exch ddef} def/*U	% - *U -{	_pola 1 sub /_pola exch ddef	_pola 0 eq	{		CRender	} if} def/D	% polarized D -{	pop} def/*w	% - *w -{} def/*W	% - *W -{} def% place operators/`	% matrix llx lly urx ury string ` -{	/_i save ddef% * special case of clipping forward without rendering	% use 'nulldevice if true	clipForward?	{		nulldevice	} if	6 1 roll 4 npop	concat pop	userdict begin	/showpage	{	} def	0 setgray	0 setlinecap	1 setlinewidth	0 setlinejoin	10 setmiterlimit	[] 0 setdash	/setstrokeadjust where {pop false setstrokeadjust} if	newpath	0 setgray	false setoverprint} def/~	% - ~ -{	end	_i restore} def% color operators/O	% flag O -{	0 ne	/_of exch ddef	/_lp /none ddef} def/R	% flag R -{	0 ne	/_os exch ddef	/_lp /none ddef} def/g	% gray g -{	/_gf exch ddef	/_fc	{		_lp /fill ne		{			_of setoverprint			_gf setgray			/_lp /fill ddef		} if	} ddef	/_pf	{		_fc		_eo {eofill} {fill} ifelse	} ddef	/_psf	{		_fc		ashow	} ddef	/_pjsf	{		_fc		awidthshow	} ddef	/_lp /none ddef} def/G	% gray G -{	/_gs exch ddef	/_sc	{		_lp /stroke ne		{			_os setoverprint			_gs setgray			/_lp /stroke ddef		} if	} ddef	/_ps	{		_sc		stroke	} ddef	/_pss	{		_sc		ss	} ddef	/_pjss	{		_sc		jss	} ddef	/_lp /none ddef} def/k	% cyan magenta yellow black k -{	_cf astore pop	/_fc	{		_lp /fill ne		{			_of setoverprint			_cf aload pop setcmykcolor			/_lp /fill ddef		} if	} ddef	/_pf	{		_fc		_eo {eofill} {fill} ifelse	} ddef	/_psf	{		_fc		ashow	} ddef	/_pjsf	{		_fc		awidthshow	} ddef	/_lp /none ddef} def/K	% cyan magenta yellow black K -{	_cs astore pop	/_sc	{		_lp /stroke ne		{			_os setoverprint			_cs aload pop setcmykcolor			/_lp /stroke ddef		} if	} ddef	/_ps	{		_sc		stroke	} ddef	/_pss	{		_sc		ss	} ddef	/_pjss	{		_sc		jss	} ddef	/_lp /none ddef} def/x	% cyan magenta yellow black name gray x -{	/_gf exch ddef	findcmykcustomcolor	/_if exch ddef	/_fc	{		_lp /fill ne		{			_of setoverprint			_if _gf 1 exch sub setcustomcolor			/_lp /fill ddef		} if	} ddef	/_pf	{		_fc		_eo {eofill} {fill} ifelse	} ddef	/_psf	{		_fc		ashow	} ddef	/_pjsf	{		_fc		awidthshow	} ddef	/_lp /none ddef} def/X	% cyan magenta yellow black name gray X -{	/_gs exch ddef	findcmykcustomcolor	/_is exch ddef	/_sc	{		_lp /stroke ne		{			_os setoverprint			_is _gs 1 exch sub setcustomcolor			/_lp /stroke ddef		} if	} ddef	/_ps	{		_sc		stroke	} ddef	/_pss	{		_sc		ss	} ddef	/_pjss	{		_sc		jss	} ddef	/_lp /none ddef} def% locked object operator/A	% value A -{	pop} def% annotate page operator/annotatepage{userdict /annotatepage 2 copy known {get exec} {pop pop} ifelse} def% object tag operator% joe holt November 20, 1994% /name (value) XT/XT {	pop pop} def% begin layer PostScript implementation% general purpose discard loop% works on early level 1 (v.23, v.38) PostScript printers% version 0.02 04/03/93% Bill Woodruff% constraints :% if nested discards must be handled% then the begin and end delimiting% strings must be of equal length% arguments% #nestingFlag% #nestingFlag = 0  				no nesting% #nestingFlag = 1  				nesting% non-nested case% note : since the non-nested case is invoked% after the ocurrence of a beginning string% we only have to look for the ending string% it is not necessary to specify a beginning string% 0 (endString) % nested case% (beginString) 1 (endString) % the discard procedure is defined in the main dictionary% it turns the discard dictionary on to execute the discard function/discard{	% test for version, hash a key	% get and execute the discard procedure from dictionary	% execute it in a stopped context so we can bail with 'stop	% wrap it in a save so we don't have to reset variables	save /discardSave exch store	discardDict begin	/endString exch store	gt38?	{		2 add	} if	load	stopped	pop	end	discardSave restore} bind def% build the discard dictionary which will contain only proceduresuserdict /discardDict 7 dict dup beginput% pre 38 initialization/pre38Initialize{	% used as buffer size for reading by byte technique		/endStringLength endString length store	/newBuff buffer 0 endStringLength getinterval store	%	new buffer equal in length to end string	/newBuffButFirst newBuff 1 endStringLength 1 sub getinterval store	%	pointer to from 2nd to last char in new buffer	/newBuffLast newBuff endStringLength 1 sub 1 getinterval store	%	pointer to last char in new buffer} def% for <=38	/shiftBuffer{	% shift last chars of newBuff to start of newBuff	newBuff 0 newBuffButFirst putinterval	% new character into last byte of newBuff	newBuffLast 0	currentfile read not	{	stop	} if	put} def% discard procedures% no nesting, older ps0{	pre38Initialize	mark	% fill the buffer	currentfile newBuff readstring exch pop	{		{			newBuff endString eq			{				cleartomark stop			} if			shiftBuffer		} loop	}	{	stop	} ifelse} def% nesting, older ps1{	pre38Initialize	/beginString exch store	mark	currentfile newBuff readstring exch pop	{		{			newBuff beginString eq			{				/layerCount dup load 1 add store			}			{				newBuff endString eq				{					/layerCount dup load 1 sub store					layerCount 0 eq					{						cleartomark stop					} if				} if			} ifelse			shiftBuffer		} loop	} if} def% no nesting, newer ps2{	mark	{		% read a line : exit if end of file reached		currentfile buffer readline not		{		stop		} if		% end of layer ?		endString eq		{			cleartomark stop		} if	} loop} def% nesting, newer ps3{	/beginString exch store	/layerCnt 1 store	mark	{		% read a line : exit if end of file reached		currentfile buffer readline not		{		stop		} if		% start of layer ?		dup beginString eq		{			% update layer counter			pop /layerCnt dup load 1 add store		}		{			% end of layer ?			endString eq			{				% stop if we're not nested				layerCnt 1 eq				{					cleartomark stop				}				{					% nested : decrement layer counter					/layerCnt dup load 1 sub store				} ifelse			} if		} ifelse	} loop} def% end discard dictionaryend% define the dictionary for clipping without renderinguserdict /clipRenderOff 15 dict dup beginput% flag for marking this dictionary as active% so we can test in /` and wrap placed% elements in nulldevice% /clipForward? true def% re-define rendering primitives to clip and newpath% based on value of /_doClip flag{	/n /N /s /S /f /F /b /B}{	{		_doClip 1 eq		{			/_doClip 0 ddef _eo {eoclip} {clip} ifelse		} if		newpath	} def} forall% modify 'Tr so Tj and Tx are never set up by% the calls to 'a0, 'e0, etc./Tr /pop load def% special case of 'cshow ?% is so, we'll have to overload toplevels% /patternashow /patternawidthshow% /patternashowstroke% /patternawidthshowstroke% /ss /jss /sp /jsp% perhaps we can bracket out patterns at a higher level ?% for example, by modifying 'E to pop off its parameters% call to 'show in 'patternpath ?% calls to 'ashow in '_psf ?% calls to 'awidthshow in '_pjsf ?% calls to 'widthshow in '_jss and '_jsp ?% disable gradient operators/Bb {} def/BB /pop load def/Bg {12 npop} def/Bm {6 npop} def/Bc /Bm load def/Bh {4 npop} def% end dictionary for clipping without renderingend/Lb	% visible preview enabled printing dimmed masks colorIndex red green blue  ==> Lb{	4 npop	6 1 roll	pop	4 1 roll	pop pop pop	% #masks #printing 	% assume that	% masks = 1 masks forward, masks = 0 no masking or only local masking		% do the right thing for printing and masking layer	0 eq	{		% non-printing layer		0 eq		{			% no masking forward from this layer			% nested discard call			(%AI5_BeginLayer) 1 (%AI5_EndLayer--) discard		}		{			% masking forward from this layer			% no printing, but clip path must survive						% set the clipForward? flag in the vars dict			/clipForward? true def						% redefine Tx and Tj in the vars dict			/Tx /pop load def			/Tj /pop load def						% turn on the no rendering dictionary			currentdict end clipRenderOff begin begin		} ifelse	}	{		% printing layer		% encapsulate layer with 'save		% only if there is no masking forward		0 eq		{			save /discardSave exch store		} if	} ifelse} bind def% end layer :% assume that if discardSave is non-null% then the layer was bracketed by 'save...restore% else we must test for clipping forward/LB	% ==> Lb ==> .....{	discardSave dup null ne	{		% undo the save		restore	}	{		pop		clipForward?		{			% assume dictionary stack :			%		vars						%		clipRenderOff						%		main			currentdict			end			end			begin			% dictionary stack :			%		vars						%		main								/clipForward? false ddef		} if	} ifelse} bind def% begin palette discard% assume no nesting/Pb	% topLeftCell selected Pb -{	pop pop	% non nested discard	0 (%AI5_EndPalette) discard} bind def% other type of discard% assume no nesting/Np{	0 (%AI5_End_NonPrinting--) discard} bind def% express layer name/Ln /pop load def	% ==> Ln ==> .....% path center-point flag operator/Ap	% value Ap -/pop load def% device-independent flatness/Ar{	72 exch div	0 dtransform dup mul exch dup mul add sqrt	dup 1 lt	{		pop 1	} if	setflat} def% multi-layer clipping/Mb{	q} def/Md{} def/MB{	Q} def% null color operators/nc 3 dict defnc begin/setgray	% gray setgray -{	pop} bind def/setcmykcolor	% cyan magenta yellow black setcmykcolor -{	4 npop} bind def/setcustomcolor	% object tint setcustomcolor -{	2 npop} bind def% exit 'nc dictionarycurrentdict readonly popend% exit main dictionary% currentdict readonly popendsetpacking%%EndResource%%EndProlog%%BeginSetup%%IncludeFont: Myriad-BoldItalicAdobe_level2_AI5 /initialize get execAdobe_screens_AI5 /initialize get execAdobe_Illustrator_AI5_vars Adobe_Illustrator_AI5 Adobe_typography_AI5 /initialize get execAdobe_Illustrator_AI5_vars Adobe_Illustrator_AI5 Adobe_blend_AI5 /initialize get execAdobe_ColorImage_AI6 /initialize get execAdobe_Illustrator_AI5 /initialize get exec[39/quotesingle 96/grave 128/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls/registered/copyright/trademark/acute/dieresis/.notdef/AE/Oslash/.notdef/plusminus/.notdef/.notdef/yen/mu/.notdef/.notdef/.notdef/.notdef/.notdef/ordfeminine/ordmasculine/.notdef/ae/oslash/questiondown/exclamdown/logicalnot/.notdef/florin/.notdef/.notdef/guillemotleft/guillemotright/ellipsis/.notdef/Agrave/Atilde/Otilde/OE/oe/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/.notdef/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave/Oacute/Ocircumflex/.notdef/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caronTE%AI3_BeginEncoding: _Myriad-BoldItalic Myriad-BoldItalic[/_Myriad-BoldItalic/Myriad-BoldItalic 0 0 1 TZ%AI3_EndEncoding AdobeType1 Bn%AI5_BeginGradient: ( 3)( 3) 0 6 Bd[0<1A1918181717161615151414131312121110100F0F0E0E0D0D0C0C0B0B0A0A090908070706060505040403030202010100><302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>01 %_Br0<212121212121202020202020201F1F1F1F1F1F1F1F1E1E1E1E1E1E1E1E1D1D1D1D1D1D1D1D1C1C1C1C1C1C1C1C1B1B1B1B1B1B1B1B1A1A1A1A1A1A1A1A><6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3A39383736353433323130>01 %_Br0<313130302F2E2D2C2C2B2A29282727262524232221><7F7F7E7D7C7C7B7A797877767574737271706F6E6D>01 %_Br0<42424241414040403F3F3E3E3E3D3D3C3C3C3B3B3A3A3A393939383837373736363535353434333333323231><ABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A8988878684838281807F>01 %_Br0<57575757575757575757575757575757575757575757575757575757575757575757575757575757575757575757575757575757575757575756565656565656565656565656565656565656565656565656565656565656565656565555555555555555555555555555555555545454545454545454545453535353535353535352525252525252525151515151515150505050504F4F4F4F4F4F4E4E4E4E4E4D4D4D4D4C4C4C4C4B4B4B4B4A4A4A4A49494948484848474747464646454545444443434342><FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFDFDFDFDFDFDFDFDFDFDFCFCFCFCFCFCFCFBFBFBFBFBFBFAFAFAFAFAF9F9F9F9F8F8F8F8F7F7F7F7F6F6F6F5F5F5F4F4F4F3F3F2F2F2F1F1F0F0F0EFEFEEEEEDEDECEBEBEAEAE9E9E8E7E7E6E5E5E4E3E3E2E1E0E0DFDEDDDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C6C5C4C3C2C0BFBEBCBBBAB8B7B5B4B3B1B0AEACAB>01 %_Br[1 0 50 100 %_Bs0 0.1 0.19 0 1 50 70 %_Bs0 0.13 0.4264 0 1 50 59 %_Bs0 0.194 0.4998 0 1 54 45 %_Bs0 0.26 0.67 0 1 50 32 %_Bs0 0.34 1 0 1 83 0 %_BsBD%AI5_EndGradient%AI5_Begin_NonPrintingNp8 Bn%AI5_BeginGradient: (Black & White)(Black & White) 0 7 Bd[<D1D3D5D7D9DBDDDEE0E1E3E4E6E7E8E9EBECEDEEEFF0F0F1F2F3F4F4F5F5F6F7F7F8F8F9F9F9FAFAFBFBFBFBFCFCFCFCFDFDFDFDFDFDFEFEFEFEFEFEFEFEFEFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF>0 %_Br<9192939495969798999A9B9C9D9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1>0 %_Br<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291>0 %_Br<9495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF>0 %_Br<82838485868788898A8B8D8E8F9091929394>0 %_Br<FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFDFDFDFDFDFDFDFDFDFDFDFDFCFCFCFCFCFCFCFCFCFBFBFBFBFBFBFBFAFAFAFAFAFAFAF9F9F9F9F9F8F8F8F8F8F8F7F7F7F7F7F6F6F6F6F5F5F5F5F4F4F4F4F3F3F3F3F2F2F2F2F1F1F1F0F0F0F0EFEFEFEEEEEEEDEDEDECECECEBEBEBEAEAE9E9E9E8E8E8E7E7E6E6E6E5E5E4E4E3E3E3E2E2E1E1E0E0DFDFDEDEDDDDDDDCDCDBDADAD9D9D8D8D7D7D6D6D5D5D4D3D3D2D2D1D1D0CFCFCECECDCCCCCBCACAC9C8C8C7C6C6C5C4C4C3C2C2C1C0C0BFBEBDBDBCBBBABAB9B8B7B7B6B5B4B4B3B2B1B0AFAFAEADACABAAAAA9A8A7A6A5A4A3A3A2A1A09F9E9D9C9B9A99989796969594939291908F8E8D8C8A8988878685848382>0 %_Br[1 0 50 100 %_Bs0.82 0 13 80 %_Bs0.57 0 50 57 %_Bs1 0 50 48 %_Bs0.58 0 50 40 %_Bs0.51 0 50 28 %_Bs1 0 76 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Green & Blue)(Green & Blue) 0 2 Bd[<99999A9A9B9B9B9C9C9D9D9D9E9E9F9F9FA0A0A1A1A1A2A2A3A3A3A4A4A5A5A5A6A6A7A7A7A8A8A9A9A9AAAAABABABACACADADADAEAEAFAFAFB0B0B1B1B1B2B2B3B3B3B4B4B5B5B5B6B6B7B7B7B8B8B9B9B9BABABBBBBBBCBCBDBDBDBEBEBFBFBFC0C0C1C1C1C2C2C3C3C3C4C4C5C5C5C6C6C7C7C7C8C8C9C9C9CACACBCBCBCCCCCDCDCDCECECFCFCFD0D0D1D1D1D2D2D3D3D3D4D4D5D5D5D6D6D7D7D7D8D8D9D9D9DADADBDBDBDCDCDDDDDDDEDEDFDFDFE0E0E1E1E1E2E2E3E3E3E4E4E5E5E5E6E6E7E7E7E8E8E9E9E9EAEAEBEBEBECECEDEDEDEEEEEFEFEFF0F0F1F1F1F2F2F3F3F3F4F4F5F5F5F6F6F7F7F7F8F8F9F9F9FAFAFBFBFBFCFCFDFDFDFEFEFFFF><000102020304050506070808090A0B0B0C0D0E0E0F101111121314141516171718191A1A1B1C1D1D1E1F20202122232324252626272829292A2B2C2C2D2E2F2F303132323334353536373838393A3B3B3C3D3E3E3F404141424344444546474748494A4A4B4C4D4D4E4F50505152535354555656575859595A5B5C5C5D5E5F5F606162626364656566676868696A6B6B6C6D6E6E6F707171727374747576777778797A7A7B7C7D7D7E7F80808182828384858586878888898A8B8B8C8D8E8E8F909191929394949596979798999A9A9B9C9D9D9E9FA0A0A1A2A3A3A4A5A6A6A7A8A9A9AAABACACADAEAFAFB0B1B2B2B3B4B5B5B6B7B8B8B9BABBBBBCBDBEBEBF><FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>01 %_Br[1 0.75 0 0 1 50 100 %_Bs0.6 0 1 0 1 50 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Pink, Yellow, Green)(Pink, Yellow, Green) 0 3 Bd[<0000000000000000000000000000000000000001010101010101010101010101010101010101010101010101010202020202020202020202020202020202020202020203030303030303030303030303030303030303030304040404040404040404040404040404040404040505050505050505050505050505050505050506060606060606060606060606060606060606070707070707070707070707070707070707080808080808080808080808080808080809090909090909090909090909090909090A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0C0D0D0D0D0D><050506060606070708080809090A0A0A0B0B0C0C0D0D0E0E0F0F101011111212131314141515161717181819191A1A1B1C1C1D1D1E1F1F202021222223232425252626272828292A2A2B2C2C2D2D2E2F2F3031313233333435353637373839393A3B3B3C3D3E3E3F4040414242434445454647474849494A4B4C4C4D4E4F4F505151525354545556575758595A5A5B5C5C5D5E5F5F606162636364656666676869696A6B6C6C6D6E6F707071727373747576777778797A7B7B7C7D7E7F7F8081828383848586878788898A8B8B8C8D8E8F8F9091929394949596979898999A9B9C9D9D9E9FA0A1A2A2A3A4A5A6A7A7A8A9AAABACADADAEAFB0B1B2B2><CCCCCBCBCBCACACAC9C9C8C8C7C7C6C6C5C5C4C4C3C2C2C1C1C0C0BFBEBEBDBDBCBBBBBAB9B9B8B7B7B6B6B5B4B4B3B2B1B1B0AFAFAEADADACABAAAAA9A8A8A7A6A5A5A4A3A2A2A1A0A09F9E9D9C9C9B9A999998979696959493929291908F8E8E8D8C8B8A8A8988878686858483828181807F7E7D7C7C7B7A7978777776757473727171706F6E6D6C6B6A6A69686766656463636261605F5E5D5C5B5B5A59585756555453525151504F4E4D4C4B4A49484746464544434241403F3E3D3C3B3A39383837363534333231302F2E2D2C2B2A29282726252423222221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>01 %_Br<737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5B5A59585756555453525150504F4E4D4C4B4A4949484746454443434241403F3E3E3D3C3B3A3A393837363635343333323130302F2E2D2D2C2B2A2A29282827262525242323222121201F1F1E1D1D1C1C1B1A1A19181817171616151414131312121111100F0F0E0E0D0D0C0C0C0B0B0A0A090908080807070606060505050404040303030202020201010101010000000000><00000000000000000000000001010101010101010101010101010101010101010101010102020202020202020202020202020202020202020202020202020303030303030303030303030303030303030303030303030303030303030304040404040404040404040404040404040404040404040404040404040404040404040404050505050505050505050505050505050505050505050505050505050505050505050505050505050505><BFBFBFC0C0C0C0C0C0C0C0C0C1C1C1C1C1C1C1C1C1C2C2C2C2C2C2C2C2C2C2C3C3C3C3C3C3C3C3C3C3C4C4C4C4C4C4C4C4C4C4C5C5C5C5C5C5C5C5C5C5C5C6C6C6C6C6C6C6C6C6C6C6C6C7C7C7C7C7C7C7C7C7C7C7C7C8C8C8C8C8C8C8C8C8C8C8C8C8C9C9C9C9C9C9C9C9C9C9C9C9C9C9C9CACACACACACACACACACACACACACACACACBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC>01 %_Br[0.05 0.7 0 0 1 50 100 %_Bs0 0.02 0.8 0 1 57 36 %_Bs0.45 0 0.75 0 1 37 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Purple, Red & Yellow)(Purple, Red & Yellow) 0 3 Bd[0<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A><CCCCCCCDCDCDCDCDCECECECECECFCFCFCFD0D0D0D0D0D1D1D1D1D1D2D2D2D2D2D3D3D3D3D3D4D4D4D4D5D5D5D5D5D6D6D6D6D6D7D7D7D7D7D8D8D8D8D8D9D9D9D9DADADADADADBDBDBDBDBDCDCDCDCDCDDDDDDDDDDDEDEDEDEDFDFDFDFDFE0E0E0E0E0E1E1E1E1E1E2E2E2E2E2E3E3E3E3E4E4E4E4E4E5E5E5E5E5E6E6E6E6E6E7E7E7E7E7E8E8E8E8E9E9E9E9E9EAEAEAEAEAEBEBEBEBEBECECECECECEDEDEDEDEEEEEEEEEEEFEFEFEFEFF0F0F0F0F0F1F1F1F1F1F2F2F2F2F3F3F3F3F3F4F4F4F4F4F5F5F5F5F5F6F6F6F6F6F7F7F7F7F8F8F8F8F8F9F9F9F9F9FAFAFAFAFAFBFBFBFBFBFCFCFCFCFDFDFDFDFDFEFEFEFEFEFFFFFF>01 %_Br<E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100><E5E6E6E6E6E6E6E6E6E7E7E7E7E7E7E7E7E7E8E8E8E8E8E8E8E8E8E9E9E9E9E9E9E9E9E9EAEAEAEAEAEAEAEAEAEBEBEBEBEBEBEBEBEBECECECECECECECECECEDEDEDEDEDEDEDEDEDEEEEEEEEEEEEEEEEEEEFEFEFEFEFEFEFEFEFF0F0F0F0F0F0F0F0F0F1F1F1F1F1F1F1F1F1F2F2F2F2F2F2F2F2F2F3F3F3F3F3F3F3F3F3F4F4F4F4F4F4F4F4F4F5F5F5F5F5F5F5F5F5F6F6F6F6F6F6F6F6F6F7F7F7F7F7F7F7F7F7F8F8F8F8F8F8F8F8F8F9F9F9F9F9F9F9F9F9FAFAFAFAFAFAFAFAFAFBFBFBFBFBFBFBFBFBFCFCFCFCFCFCFCFCFCFDFDFDFDFDFDFDFDFDFEFEFEFEFEFEFEFEFEFFFFFFFFFF><00010203040405060708090A0B0C0C0D0E0F10111213141415161718191A1B1C1D1D1E1F20212223242525262728292A2B2C2D2D2E2F30313233343535363738393A3B3C3D3D3E3F40414243444545464748494A4B4C4D4E4E4F50515253545556565758595A5B5C5D5E5E5F60616263646566666768696A6B6C6D6E6E6F70717273747576767778797A7B7C7D7E7F7F80818283848586878788898A8B8C8D8E8F8F90919293949596979798999A9B9C9D9E9F9FA0A1A2A3A4A5A6A7A7A8A9AAABACADAEAFAFB0B1B2B3B4B5B6B7B8B8B9BABBBCBDBEBFC0C0C1C2C3C4C5C6C7C8C8C9CACBCC>01 %_Br[0 0.04 1 0 1 50 100 %_Bs0 1 0.8 0 1 50 50 %_Bs0.9 0.9 0 0 1 50 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Rainbow)(Rainbow) 0 6 Bd[<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>1001 %_Br1<0708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF>001 %_Br1<00000000000000000000000000000000000001010101010101010101010101010101010101010101010101010101010101010101010102020202020202020202020202020202020202020202020202020202020202020202020203030303030303030303030303030303030303030303030303030303030303030303030304040404040404040404040404040404040404040404040404040404040404040404040405050505050505050505050505050505050505050505050505050505050505050505050506060606060606060606060606060606060606060606060606060606060606060606060607070707070707070707070707070707070707070707><FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>01 %_Br<000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF>0101 %_Br0<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>101 %_Br[0 1 0 0 1 50 100 %_Bs1 1 0 0 1 50 80 %_Bs1 0.0279 0 0 1 50 60 %_Bs1 0 1 0 1 50 40 %_Bs0 0 1 0 1 50 20 %_Bs0 1 1 0 1 50 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Steel Bar)(Steel Bar) 0 3 Bd[<FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A898887868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A696867666564636261605F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A393837363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A191817161514131211100F0E0D0C0B0A09080706050403020100>0 %_Br<000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF>0 %_Br[0 0 50 100 %_Bs1 0 50 70 %_Bs0 0 50 0 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Yellow & Orange Radial)(Yellow & Orange Radial) 1 2 Bd[0<0001010203040506060708090A0B0C0C0D0E0F10111213131415161718191A1B1C1D1D1E1F202122232425262728292A2B2B2C2D2E2F303132333435363738393A3B3C3D3E3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F60606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C><FFFFFFFFFEFEFEFEFEFEFEFDFDFDFDFDFDFCFCFCFCFCFCFBFBFBFBFBFBFAFAFAFAFAFAF9F9F9F9F9F9F8F8F8F8F8F8F7F7F7F7F7F7F6F6F6F6F6F6F5F5F5F5F5F5F4F4F4F4F4F3F3F3F3F3F3F2F2F2F2F2F2F1F1F1F1F1F0F0F0F0F0F0EFEFEFEFEFEFEEEEEEEEEEEDEDEDEDEDEDECECECECECEBEBEBEBEBEBEAEAEAEAEAE9E9E9E9E9E9E8E8E8E8E8E8E7E7E7E7E7E6E6E6E6E6E5>01 %_Br[0 0 1 0 1 52 19 %_Bs0 0.55 0.9 0 1 50 100 %_BsBD%AI5_EndGradient%AI5_BeginGradient: (Yellow & Purple Radial)(Yellow & Purple Radial) 1 2 Bd[<000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF><1415161718191A1B1C1D1E1F1F202122232425262728292A2A2B2C2D2E2F30313233343536363738393A3B3C3D3E3F40414142434445464748494A4B4C4D4D4E4F50515253545556575858595A5B5C5D5E5F60616263646465666768696A6B6C6D6E6F6F707172737475767778797A7B7B7C7D7E7F80818283848586868788898A8B8C8D8E8F90919292939495969798999A9B9C9D9D9E9FA0A1A2A3A4A5A6A7A8A9A9AAABACADAEAFB0B1B2B3B4B4B5B6B7B8B9BABBBCBDBEBFC0C0C1C2C3C4C5C6C7C8C9CACBCBCCCDCECFD0D1D2D3D4D5D6D7D7D8D9DADBDCDDDEDFE0E1E2E2E3E4E5E6E7E8E9EAEBECEDEEEEEFF0F1F2F3F4F5F6F7F8F9F9FAFBFCFDFEFF><ABAAAAA9A8A7A7A6A5A5A4A3A3A2A1A1A09F9F9E9D9D9C9B9B9A9999989797969595949393929191908F8F8E8D8D8C8B8B8A8989888787868585848383828181807F7F7E7D7D7C7B7B7A7979787777767575747373727171706F6F6E6D6D6C6B6B6A6969686767666565646362626160605F5E5E5D5C5C5B5A5A5958585756565554545352525150504F4E4E4D4C4C4B4A4A4948484746464544444342424140403F3E3E3D3C3C3B3A3A3938383736363534343332323130302F2E2E2D2C2C2B2A2A29282827262625242423222121201F1F1E1D1D1C1B1B1A1919181717161515141313121111100F0F0E0D0D0C0B0B0A090908070706050504030302010100>01 %_Br[0 0.08 0.67 0 1 50 14 %_Bs1 1 0 0 1 50 100 %_BsBD%AI5_EndGradient%AI5_End_NonPrinting--%AI5_BeginPalette0 22 PbPnPc1 gPc0 gPc0 0 0 0 kPc0.75 gPc0.5 gPc0.25 gPc0 gPcBb2 (Black & White) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.25 0 0 0 kPc0.5 0 0 0 kPc0.75 0 0 0 kPc1 0 0 0 kPc1 0.27 0 0.16 kPc0.5 0.5 0 0 kPc0.75 0.75 0 0 kPc1 1 0 0 kPcBb2 (Pink, Yellow, Green) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0 0.25 0 0 kPc0.46 0 1 0 kPc0 0.75 0 0 kPc0 1 0 0 kPc0 0.7 1 0 kPc0 0.5 0.5 0 kPc0 0.75 0.75 0 kPc0 1 1 0 kPcBb0 0 0 0 Bh2 (Yellow & Purple Radial) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0 0 0.25 0 kPc0 0 0.5 0 kPc0 0 0.75 0 kPc0 0 1 0 kPc0.25 0 0.25 0 kPc0.5 0 0.5 0 kPc0.75 0 0.75 0 kPc1 0 1 0 kPcBb2 (Rainbow) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.25 0.125 0 0 kPc0.5 0.25 0 0 kPc0.75 0.375 0 0 kPc1 0.5 0 0 kPc0.125 0.25 0 0 kPc0.25 0.5 0 0 kPc0.375 0.75 0 0 kPc0.5 1 0 0 kPcBb2 (Steel Bar) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0 0.25 0.125 0 kPc0 0.5 0.25 0 kPc0 0.75 0.375 0 kPc0 1 0.5 0 kPc0 0.125 0.25 0 kPc0 0.25 0.5 0 kPc0 0.375 0.75 0 kPc0 0.5 1 0 kPcBb2 (Purple, Red & Yellow) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.125 0 0.25 0 kPc0.25 0 0.5 0 kPc0.375 0 0.75 0 kPc0.5 0 1 0 kPc0.25 0 0.125 0 kPc0.5 0 0.25 0 kPc0.75 0 0.375 0 kPc1 0 0.5 0 kPcBb2 (Green & Blue) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.25 0.125 0.125 0 kPc0.5 0.25 0.25 0 kPc0.75 0.375 0.375 0 kPc1 0.5 0.5 0 kPc0.25 0.25 0.125 0 kPc0.5 0.5 0.25 0 kPc0.75 0.75 0.375 0 kPc1 1 0.5 0 kPcBb0 0 0 0 Bh2 (Yellow & Orange Radial) -4014 4716 0 0 1 0 0 1 0 0 Bg0 BBPc0.125 0.25 0.125 0 kPc0.25 0.5 0.25 0 kPc0.375 0.75 0.375 0 kPc0.5 1 0.5 0 kPc0.125 0.25 0.25 0 kPc0.25 0.5 0.5 0 kPc0.375 0.75 0.75 0 kPc0.5 1 1 0 kPc0 0 0 0 kPc0.125 0.125 0.25 0 kPc0.25 0.25 0.5 0 kPc0.375 0.375 0.75 0 kPc0.5 0.5 1 0 kPc0.25 0.125 0.25 0 kPc0.5 0.25 0.5 0 kPc0.75 0.375 0.75 0 kPc1 0.5 1 0 kPcPB%AI5_EndPalette%%EndSetup%AI5_BeginLayer1 1 1 1 0 0 0 79 128 255 Lb(Layer 1) Ln0 Auu*u0 O0.27 0 0.64 0 k800 Ar0 J 0 j 1 w 4 M []0 d%AI3_Note:0 D0 XR164.1476 415.5158 m162.1311 422.5648 L161.1666 415.3404 L159.0975 415.6385 L161.0965 426.0368 L162.9903 426.0368 L165.0944 418.4617 L167.1987 426.0368 L169.0924 426.0368 L171.0915 415.6385 L169.0223 415.3404 L168.0579 422.5648 L166.0413 415.5158 L164.1476 415.5158 lf*U*u178.5791 418.9877 m178.5791 417.8304 179 417.0238 179.9118 416.3224 c178.2284 415.3229 L177.8953 415.5508 177.492 416.1119 177.3692 416.2873 c176.5626 415.2527 175.1247 415.2527 v173.6518 415.2527 172.1788 416.375 172.1788 417.9707 c172.1788 419.7066 173.757 420.7763 175.6508 420.7763 c175.9489 420.7763 176.5801 420.7763 y176.5801 421.5303 176.1418 422.0037 175.3001 422.0037 c174.9319 422.0037 174.3356 421.8985 173.8798 421.5829 c173.1608 423.1786 L174.0025 423.8449 175.3001 423.8449 v177.4744 423.8449 178.5791 422.4596 178.5791 420.6886 C178.5791 418.9877 lf1 D176.5801 419.2332 m175.7209 419.2332 175.6508 419.2332 v174.4058 419.2332 174.2129 418.4441 174.2129 417.9707 c174.2129 417.4095 174.7389 417.1114 175.1949 417.1114 c176.019 417.1114 176.6853 417.883 y176.5801 418.5493 176.5801 419.2332 vf*U*u0 D184.488 418.8825 m184.488 417.7251 184.9089 416.9186 185.8207 416.2172 c184.1373 415.2177 L182.98 416.2522 182.489 417.3219 182.489 418.8825 c182.489 421.5829 L180.9985 421.5829 L180.9985 423.5819 L182.489 423.5819 L182.489 426.0368 L184.488 426.0368 L184.488 423.5819 L186.0662 423.5819 L186.0662 421.5829 L184.488 421.5829 L184.488 418.8825 lf*U*u187.9246 427.6149 m189.9235 427.6149 L189.9235 422.5298 L190.888 423.88 192.2206 423.88 v193.6585 423.88 194.658 422.8805 194.658 421.39 c194.658 415.5158 L192.659 415.5158 L192.659 420.3554 L192.659 421.0218 192.659 421.8459 191.8173 421.8459 c190.3269 421.8459 189.9235 420.1275 y189.9235 415.5158 L187.9246 415.5158 L187.9246 427.6149 lf*U*u198.3937 419.1104 m197.517 419.4962 196.7279 420.0748 196.7279 421.39 c196.7279 422.8805 198.1307 423.8449 199.5335 423.8449 c200.6733 423.8449 201.5501 423.3715 202.0761 422.8805 c200.9363 421.39 L200.5856 421.7407 200.1823 422.0037 199.6212 422.0037 c199.0952 422.0037 198.6568 421.8284 198.6568 421.39 c198.6568 420.9165 199.4459 420.7061 199.8842 420.5132 c200.6733 420.1625 L201.5501 419.7768 202.2514 419.1981 202.2514 417.883 c202.2514 416.375 200.761 415.2527 199.1828 415.2527 c198.2184 415.2527 197.2364 415.621 196.4649 416.3224 c197.6047 417.9707 L197.9554 417.4797 198.7444 417.0588 199.2705 417.0588 c199.9719 417.0588 200.3226 417.3569 200.3226 417.7953 c200.3226 418.2337 199.6212 418.5668 199.1828 418.7597 C198.3937 419.1104 lf*U*u209.2816 420.2151 m204.5471 420.2151 L204.5471 422.3895 L209.2816 422.3895 L209.2816 420.2151 lf*U*u216.5228 415.5158 m214.5063 422.5648 L213.5419 415.3404 L211.4727 415.6385 L213.4717 426.0368 L215.3655 426.0368 L217.4697 418.4617 L219.5739 426.0368 L221.4677 426.0368 L223.4667 415.6385 L221.3976 415.3404 L220.4332 422.5648 L218.4166 415.5158 L216.5228 415.5158 lf*U*u230.9544 418.9877 m230.9544 417.8304 231.3752 417.0238 232.287 416.3224 c230.6037 415.3229 L230.2705 415.5508 229.8672 416.1119 229.7445 416.2873 c228.9378 415.2527 227.5 415.2527 v226.027 415.2527 224.5541 416.375 224.5541 417.9707 c224.5541 419.7066 226.1322 420.7763 228.026 420.7763 c228.3241 420.7763 228.9554 420.7763 y228.9554 421.5303 228.517 422.0037 227.6753 422.0037 c227.3071 422.0037 226.7109 421.8985 226.255 421.5829 c225.536 423.1786 L226.3777 423.8449 227.6753 423.8449 v229.8497 423.8449 230.9544 422.4596 230.9544 420.6886 C230.9544 418.9877 lf1 D228.9554 419.2332 m228.0961 419.2332 228.026 419.2332 v226.781 419.2332 226.5882 418.4441 226.5882 417.9707 c226.5882 417.4095 227.1142 417.1114 227.5701 417.1114 c228.3943 417.1114 229.0606 417.883 y228.9554 418.5493 228.9554 419.2332 vf*U*u0 D235.25 419.1104 m234.3733 419.4962 233.5842 420.0748 233.5842 421.39 c233.5842 422.8805 234.987 423.8449 236.3898 423.8449 c237.5296 423.8449 238.4064 423.3715 238.9324 422.8805 c237.7926 421.39 L237.442 421.7407 237.0386 422.0037 236.4775 422.0037 c235.9515 422.0037 235.5131 421.8284 235.5131 421.39 c235.5131 420.9165 236.3021 420.7061 236.7405 420.5132 c237.5296 420.1625 L238.4064 419.7768 239.1078 419.1981 239.1078 417.883 c239.1078 416.375 237.6173 415.2527 236.0391 415.2527 c235.0747 415.2527 234.0928 415.621 233.3212 416.3224 c234.4609 417.9707 L234.8117 417.4797 235.6007 417.0588 236.1268 417.0588 c236.8282 417.0588 237.1789 417.3569 237.1789 417.7953 c237.1789 418.2337 236.4775 418.5668 236.0391 418.7597 C235.25 419.1104 lf*U*u244.0512 418.8825 m244.0512 417.7251 244.472 416.9186 245.3839 416.2172 c243.7005 415.2177 L242.5431 416.2522 242.0522 417.3219 242.0522 418.8825 c242.0522 421.5829 L240.5617 421.5829 L240.5617 423.5819 L242.0522 423.5819 L242.0522 426.0368 L244.0512 426.0368 L244.0512 423.5819 L245.6293 423.5819 L245.6293 421.5829 L244.0512 421.5829 L244.0512 418.8825 lf*U*u250.644 417.1816 m251.8715 417.1816 252.4326 417.8654 y253.5549 416.7432 L252.4852 415.2527 250.644 415.2527 v248.4171 415.2527 246.9967 417.3219 246.9967 419.5488 c246.9967 421.7758 248.4521 423.8449 250.644 423.8449 c252.3975 423.8449 253.5022 422.8805 253.9932 421.3374 c253.0814 419.4436 251.5558 418.4441 249.4516 418.4441 c249.3114 418.4441 249.1535 418.4441 y249.2237 418.2161 249.5393 417.1816 250.644 417.1816 cf1 D249.0483 419.9697 m250.6265 419.9697 251.3103 420.4431 251.9066 421.3374 c251.4857 421.8809 250.644 421.8809 v249.2588 421.8809 249.0483 419.9697 yf*U*u0 D258.4645 420.2678 m258.4645 415.5158 L256.4655 415.5158 L256.4655 420.1099 L256.4655 421.2673 256.0446 422.0739 255.1328 422.7752 c256.8162 423.7748 L257.1844 423.4942 257.7982 422.6525 257.8332 422.5824 c259.1659 423.8449 260.3583 423.8449 v260.744 421.7582 l259.6569 421.8108 258.4645 420.2678 yf*UU199.0744 413.2315 mBb2 ( 3) 153.6667 657.0833 0 151 0.3067 0 0 0.3067 2888.6964 3049.7478 Bg1 0 0 -1 -4014 4716 Bc0.32 0 0 -1 -4014 4716 Bm0.13 0 0 -1 -4013.68 4716 Bm0.14 0 0 -1 -4013.55 4716 Bm0.11 0 0 -1 -4013.41 4716 Bm0.3 0 0 -1 -4013.3 4716 Bm1 0 0 -1 -4014 4716 BcF0 BBu*u1 0.27 0 0.16 k163.0806 416.1207 m161.0641 423.1698 L160.0996 415.9454 L158.0305 416.2434 L160.0295 426.6418 L161.9233 426.6418 L164.0275 419.0666 L166.1317 426.6418 L168.0255 426.6418 L170.0245 416.2434 L167.9553 415.9454 L166.9909 423.1698 L164.9744 416.1207 L163.0806 416.1207 lf*U*u177.5122 419.5927 m177.5122 418.4354 177.933 417.6287 178.8448 416.9273 c177.1614 415.9279 L176.8283 416.1558 176.425 416.7169 176.3022 416.8923 c175.4956 415.8577 174.0577 415.8577 v172.5848 415.8577 171.1118 416.9799 171.1118 418.5756 c171.1118 420.3116 172.69 421.3812 174.5838 421.3812 c174.8819 421.3812 175.5132 421.3812 y175.5132 422.1353 175.0748 422.6087 174.2331 422.6087 c173.8649 422.6087 173.2687 422.5035 172.8127 422.1878 c172.0938 423.7835 L172.9355 424.4499 174.2331 424.4499 v176.4075 424.4499 177.5122 423.0646 177.5122 421.2936 C177.5122 419.5927 lf1 D175.5132 419.8382 m174.6539 419.8382 174.5838 419.8382 v173.3388 419.8382 173.1459 419.0491 173.1459 418.5756 c173.1459 418.0145 173.6719 417.7164 174.1279 417.7164 c174.952 417.7164 175.6183 418.488 y175.5132 419.1543 175.5132 419.8382 vf*U*u0 D183.421 419.4875 m183.421 418.3302 183.8419 417.5235 184.7537 416.8222 c183.0703 415.8226 L181.913 416.8572 181.422 417.9268 181.422 419.4875 c181.422 422.1878 L179.9315 422.1878 L179.9315 424.1869 L181.422 424.1869 L181.422 426.6418 L183.421 426.6418 L183.421 424.1869 L184.9992 424.1869 L184.9992 422.1878 L183.421 422.1878 L183.421 419.4875 lf*U*u186.8576 428.2199 m188.8565 428.2199 L188.8565 423.1348 L189.821 424.485 191.1537 424.485 v192.5915 424.485 193.591 423.4855 193.591 421.995 c193.591 416.1207 L191.592 416.1207 L191.592 420.9604 L191.592 421.6267 191.592 422.4509 190.7504 422.4509 c189.2599 422.4509 188.8565 420.7325 y188.8565 416.1207 L186.8576 416.1207 L186.8576 428.2199 lf*U*u197.3267 419.7154 m196.45 420.1012 195.6609 420.6799 195.6609 421.995 c195.6609 423.4855 197.0637 424.4499 198.4665 424.4499 c199.6063 424.4499 200.4831 423.9764 201.0091 423.4855 c199.8693 421.995 L199.5186 422.3457 199.1153 422.6087 198.5542 422.6087 c198.0282 422.6087 197.5898 422.4333 197.5898 421.995 c197.5898 421.5215 198.3789 421.3111 198.8173 421.1182 c199.6063 420.7675 L200.4831 420.3818 201.1845 419.8031 201.1845 418.488 c201.1845 416.9799 199.694 415.8577 198.1159 415.8577 c197.1514 415.8577 196.1694 416.2259 195.3979 416.9273 c196.5377 418.5756 L196.8884 418.0847 197.6775 417.6638 198.2035 417.6638 c198.9049 417.6638 199.2556 417.9619 199.2556 418.4003 c199.2556 418.8386 198.5542 419.1718 198.1159 419.3647 C197.3267 419.7154 lf*U*u208.2145 420.8201 m203.4801 420.8201 L203.4801 422.9945 L208.2145 422.9945 L208.2145 420.8201 lf*U*u215.4558 416.1207 m213.4393 423.1698 L212.4749 415.9454 L210.4057 416.2434 L212.4047 426.6418 L214.2985 426.6418 L216.4027 419.0666 L218.5069 426.6418 L220.4007 426.6418 L222.3997 416.2434 L220.3306 415.9454 L219.3661 423.1698 L217.3496 416.1207 L215.4558 416.1207 lf*U*u229.8874 419.5927 m229.8874 418.4354 230.3083 417.6287 231.2201 416.9273 c229.5367 415.9279 L229.2035 416.1558 228.8002 416.7169 228.6775 416.8923 c227.8709 415.8577 226.433 415.8577 v224.96 415.8577 223.4871 416.9799 223.4871 418.5756 c223.4871 420.3116 225.0652 421.3812 226.9591 421.3812 c227.2571 421.3812 227.8884 421.3812 y227.8884 422.1353 227.45 422.6087 226.6083 422.6087 c226.2401 422.6087 225.6439 422.5035 225.188 422.1878 c224.4691 423.7835 L225.3107 424.4499 226.6083 424.4499 v228.7827 424.4499 229.8874 423.0646 229.8874 421.2936 C229.8874 419.5927 lf1 D227.8884 419.8382 m227.0292 419.8382 226.9591 419.8382 v225.714 419.8382 225.5212 419.0491 225.5212 418.5756 c225.5212 418.0145 226.0472 417.7164 226.5031 417.7164 c227.3273 417.7164 227.9936 418.488 y227.8884 419.1543 227.8884 419.8382 vf*U*u0 D234.1831 419.7154 m233.3063 420.1012 232.5172 420.6799 232.5172 421.995 c232.5172 423.4855 233.92 424.4499 235.3228 424.4499 c236.4626 424.4499 237.3394 423.9764 237.8654 423.4855 c236.7256 421.995 L236.3749 422.3457 235.9716 422.6087 235.4105 422.6087 c234.8845 422.6087 234.4461 422.4333 234.4461 421.995 c234.4461 421.5215 235.2351 421.3111 235.6735 421.1182 c236.4626 420.7675 L237.3394 420.3818 238.0408 419.8031 238.0408 418.488 c238.0408 416.9799 236.5503 415.8577 234.9721 415.8577 c234.0077 415.8577 233.0257 416.2259 232.2542 416.9273 c233.394 418.5756 L233.7447 418.0847 234.5338 417.6638 235.0598 417.6638 c235.7612 417.6638 236.1119 417.9619 236.1119 418.4003 c236.1119 418.8386 235.4105 419.1718 234.9721 419.3647 C234.1831 419.7154 lf*U*u242.9842 419.4875 m242.9842 418.3302 243.405 417.5235 244.3168 416.8222 c242.6335 415.8226 L241.4762 416.8572 240.9852 417.9268 240.9852 419.4875 c240.9852 422.1878 L239.4947 422.1878 L239.4947 424.1869 L240.9852 424.1869 L240.9852 426.6418 L242.9842 426.6418 L242.9842 424.1869 L244.5623 424.1869 L244.5623 422.1878 L242.9842 422.1878 L242.9842 419.4875 lf*U*u249.577 417.7866 m250.8045 417.7866 251.3656 418.4704 y252.4878 417.3482 L251.4182 415.8577 249.577 415.8577 v247.3501 415.8577 245.9297 417.9268 245.9297 420.1538 c245.9297 422.3808 247.3851 424.4499 249.577 424.4499 c251.3305 424.4499 252.4352 423.4855 252.9262 421.9424 c252.0144 420.0486 250.4889 419.0491 248.3846 419.0491 c248.2444 419.0491 248.0865 419.0491 y248.1567 418.8211 248.4723 417.7866 249.577 417.7866 cf1 D247.9813 420.5746 m249.5595 420.5746 250.2434 421.0481 250.8395 421.9424 c250.4187 422.486 249.577 422.486 v248.1917 422.486 247.9813 420.5746 yf*U*u0 D257.3975 420.8727 m257.3975 416.1207 L255.3985 416.1207 L255.3985 420.7149 L255.3985 421.8722 254.9777 422.6788 254.0658 423.3802 c255.7492 424.3798 L256.1174 424.0992 256.7312 423.2575 256.7662 423.1874 c258.0989 424.4499 259.2913 424.4499 v259.6771 422.3632 l258.5899 422.4158 257.3975 420.8727 yf*UUU-4014 415.9375 m4626 415.9375 L(N) *u*u0 O1 0.1 0 0 k432.5206 423.6326 m433.0906 423.7289 433.9354 423.8016 434.8796 423.8016 c436.0439 423.8016 436.8598 423.6238 437.42 423.1797 c437.8887 422.8076 438.1466 422.2559 438.1466 421.5339 c438.1466 420.5395 437.4355 419.8467 436.7607 419.6046 c436.7607 419.5677 L437.3053 419.3477 437.6118 418.8271 437.8097 418.1059 c438.0522 417.2174 438.2891 416.1943 438.4431 415.8901 c436.6259 415.8901 L436.5053 416.1173 436.3095 416.7483 436.0861 417.72 c435.8674 418.7012 435.5378 418.9632 434.8072 418.9725 c434.2794 418.9725 L434.2794 415.8901 L432.5206 415.8901 L432.5206 423.6326 lf1 D434.2794 420.2567 m434.9746 420.2567 L435.8553 420.2567 436.382 420.7056 436.382 421.388 c436.382 422.1066 435.8894 422.474 435.0785 422.4787 c434.6536 422.4787 434.4046 422.451 434.2794 422.4192 C434.2794 420.2567 lf*U*u0 D448.9654 417.7223 m449.4355 417.4701 450.1739 417.2293 450.9331 417.2293 c451.7483 417.2293 452.1806 417.5678 452.1806 418.0844 c452.1806 418.5664 451.8059 418.8506 450.8662 419.1818 c449.5565 419.6462 448.7007 420.3598 448.7007 421.5066 c448.7007 422.845 449.8245 423.8628 451.6702 423.8628 c452.5653 423.8628 453.2116 423.6849 453.6747 423.4676 c453.2823 422.0441 L452.9711 422.1927 452.406 422.4169 451.6438 422.4169 c450.8709 422.4169 450.5019 422.0592 450.5019 421.6578 c450.5019 421.1592 450.9368 420.9386 451.9551 420.554 c453.345 420.0345 453.9884 419.3131 453.9884 418.2033 c453.9884 416.8927 452.9849 415.7679 450.8238 415.7679 c449.9341 415.7679 449.044 416.0099 448.6065 416.2559 C448.9654 417.7223 lf*U*u455.7836 423.7403 m457.5423 423.7403 L457.5423 420.2704 L457.5717 420.2704 L457.7437 420.5675 457.9314 420.8515 458.1106 421.126 c459.8879 423.7403 L462.0693 423.7403 L459.4722 420.3995 L462.2065 415.8901 L460.1405 415.8901 L458.2089 419.2746 L457.5423 418.4538 L457.5423 415.8901 L455.7836 415.8901 L455.7836 423.7403 lf*U1 Ap0.46 0 1 0 k446.015 422.283 m444.6548 423.6434 442.4493 423.6434 441.0889 422.283 c439.7287 420.9228 439.7287 418.7173 441.0889 417.3571 c442.4493 415.9967 444.6548 415.9967 446.015 417.3571 c447.3752 418.7173 447.3752 420.9228 446.015 422.283 cf0 Ap1 g0.5 w445.7023 419.5717 m443.2984 419.6254 L444.4611 417.525 L444.5206 418.0969 444.7548 418.5584 V446.6845 417.3882 L446.8449 417.6529 L444.9183 418.8213 L445.2249 419.2336 445.7023 419.5717 YfU1 w-4014 416.0833 m4626 416.0833 L(N) *299.1667 4716 m299.1667 -3924 L(N) *-4014 422.5 m4626 422.5 L(N) *398.5 4716 m398.5 -3924 L(N) *0 To1 0 0 1 298.8333 415.8958 0 TpTP0 Tr0 O0 0.7 1 0 k/_Myriad-BoldItalic 9.9213 Tf0 Ts100 Tz37 Tt1 TA%_ 0 XL36 0 XbXB0 0 5 TC100 100 200 TW0 0 0 Ti0 Ta0 0 2 2 3 Th0 Tq0 0 Tl0.3671 Tc0 Tw(LEA) Tx 1 67 Tk(VING CER) Tx 1 13 Tk(TIFIC) Tx 1 -7 Tk(A) Tx 1 83 Tk(TE) Tx(\r) TX TO*u0.27 0 0.64 0 k263.7674 415.4953 m263.7674 416.2616 L264.4588 416.8863 L265.6499 417.9525 266.2247 418.5606 266.233 419.1936 c266.233 419.6351 265.9748 419.9849 265.35 419.9849 c264.8836 419.9849 264.4754 419.7517 264.1922 419.5434 c263.8341 420.443 L264.2339 420.7512 264.8753 421.0011 265.5999 421.0011 c266.8327 421.0011 267.499 420.2848 267.499 419.3019 c267.499 418.394 266.8494 417.6693 266.058 416.9696 c265.5583 416.5532 L265.5583 416.5365 L267.6073 416.5365 L267.6073 415.4953 L263.7674 415.4953 lf*U*u269.1829 415.4037 m268.7581 415.4037 268.4499 415.7285 268.4499 416.17 c268.4499 416.6281 268.7581 416.9447 269.1995 416.9447 c269.6327 416.9447 269.9325 416.6364 269.9409 416.17 c269.9409 415.7285 269.641 415.4037 269.1912 415.4037 C269.1829 415.4037 lf*U*u272.4969 415.4037 m271.0976 415.4037 270.4812 416.6614 270.4729 418.1941 c270.4729 419.7683 271.1309 421.0011 272.5302 421.0011 c273.9712 421.0011 274.546 419.71 274.546 418.2274 c274.546 416.5615 273.8713 415.4037 272.5052 415.4037 C272.4969 415.4037 lf1 D272.5136 416.3616 m273.005 416.3616 273.2716 416.9779 273.2716 418.2107 c273.2716 419.4102 273.0133 420.0432 272.5052 420.0432 c272.0305 420.0432 271.7306 419.4351 271.7306 418.2107 c271.7223 416.9613 272.0221 416.3616 272.5052 416.3616 C272.5136 416.3616 lf*U*u1 0.27 0 0.16 k0 D263.4698 416.0905 m263.4698 416.8568 L264.1612 417.4815 L265.3523 418.5477 265.927 419.1558 265.9354 419.7888 c265.9354 420.2303 265.6772 420.5801 265.0524 420.5801 c264.586 420.5801 264.1779 420.3469 263.8946 420.1386 c263.5365 421.0382 L263.9363 421.3464 264.5777 421.5963 265.3023 421.5963 c266.5351 421.5963 267.2015 420.88 267.2015 419.8971 c267.2015 418.9892 266.5518 418.2645 265.7604 417.5648 c265.2607 417.1484 L265.2607 417.1317 L267.3097 417.1317 L267.3097 416.0905 L263.4698 416.0905 lf*U*u268.8853 415.9989 m268.4605 415.9989 268.1523 416.3237 268.1523 416.7652 c268.1523 417.2233 268.4605 417.5398 268.9019 417.5398 c269.3351 417.5398 269.6349 417.2316 269.6432 416.7652 c269.6432 416.3237 269.3434 415.9989 268.8936 415.9989 C268.8853 415.9989 lf*U*u272.1993 415.9989 m270.8 415.9989 270.1836 417.2566 270.1753 418.7893 c270.1753 420.3635 270.8333 421.5963 272.2326 421.5963 c273.6736 421.5963 274.2484 420.3052 274.2484 418.8226 c274.2484 417.1567 273.5737 415.9989 272.2077 415.9989 C272.1993 415.9989 lf1 D272.216 416.9568 m272.7074 416.9568 272.974 417.5732 272.974 418.8059 c272.974 420.0054 272.7158 420.6384 272.2077 420.6384 c271.7329 420.6384 271.433 420.0303 271.433 418.8059 c271.4247 417.5565 271.7245 416.9568 272.2077 416.9568 C272.216 416.9568 lf*ULB%AI5_EndLayer--%%PageTrailergsave annotatepage grestore showpage%%TrailerAdobe_Illustrator_AI5 /terminate get execAdobe_ColorImage_AI6 /terminate get execAdobe_blend_AI5 /terminate get execAdobe_typography_AI5 /terminate get execAdobe_screens_AI5 /terminate get execAdobe_level2_AI5 /terminate get exec%%EOF